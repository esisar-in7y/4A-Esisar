{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"aidememoire/","text":"Aide m\u00e9moire Java \u00b6 Voici un aide m\u00e9moire sur des notions de base en Java. Manipulation de cha\u00eenes de caract\u00e8res en Java \u00b6 Comment transformer une cha\u00eene de caract\u00e8res en nombre : String s1 = \"123\" ; int a = Integer . parseInt ( s1 ); Comment trouver l'index d'un caract\u00e8re dans une cha\u00eene : String s2 = \"abcdef\" ; int indice = s2 . indexOf ( 'c' ); System . out . println ( \"indice=\" + indice ); // Affiche \"indice=2 Comment v\u00e9rifier si une cha\u00eene de caract\u00e8res contient une sous chaine ? String s3 = \"abc\" ; boolean b30 = s3 . contains ( \"a\" ); // b30 est \u00e9gal \u00e0 true boolean b31 = s3 . contains ( \"z\" ); // b31 est \u00e9gal \u00e0 false Comment extraire une sous chaine d'une cha\u00eene de caract\u00e8res? String s4 = \"abcdef\" ; String s5 = s4 . substring ( 2 ); // s5 contient cdef String s6 = s4 . substring ( 2 , 4 ); // s6 contient cd","title":"Aide m\u00e9moire Java"},{"location":"aidememoire/#aide-memoire-java","text":"Voici un aide m\u00e9moire sur des notions de base en Java.","title":"Aide m\u00e9moire Java"},{"location":"aidememoire/#manipulation-de-chaines-de-caracteres-en-java","text":"Comment transformer une cha\u00eene de caract\u00e8res en nombre : String s1 = \"123\" ; int a = Integer . parseInt ( s1 ); Comment trouver l'index d'un caract\u00e8re dans une cha\u00eene : String s2 = \"abcdef\" ; int indice = s2 . indexOf ( 'c' ); System . out . println ( \"indice=\" + indice ); // Affiche \"indice=2 Comment v\u00e9rifier si une cha\u00eene de caract\u00e8res contient une sous chaine ? String s3 = \"abc\" ; boolean b30 = s3 . contains ( \"a\" ); // b30 est \u00e9gal \u00e0 true boolean b31 = s3 . contains ( \"z\" ); // b31 est \u00e9gal \u00e0 false Comment extraire une sous chaine d'une cha\u00eene de caract\u00e8res? String s4 = \"abcdef\" ; String s5 = s4 . substring ( 2 ); // s5 contient cdef String s6 = s4 . substring ( 2 , 4 ); // s6 contient cd","title":"Manipulation de cha\u00eenes de caract\u00e8res en Java"},{"location":"exemples/","text":"Exemples du cours \u00b6 Voici divers exemples de codes sur les notions vues durant ce cours L'API des sockets en Java - UDP \u00b6 R\u00e9aliser un client UDP en Java package udp ; import java.io.IOException ; import java.net.DatagramPacket ; import java.net.DatagramSocket ; import java.net.InetSocketAddress ; /** * Client basique UDP * */ public class ClientUDP { public static void main ( String [] args ) throws Exception { ClientUDP clientUDP = new ClientUDP (); clientUDP . execute (); } /** * Le client cree une socket, envoie un message au serveur * et attend la reponse * */ private void execute () throws IOException { // System . out . println ( \"Demarrage du client ...\" ); //Creation de la socket DatagramSocket socket = new DatagramSocket (); // Creation et envoi du message InetSocketAddress adrDest = new InetSocketAddress ( \"127.0.0.1\" , 5099 ); byte [] bufE = new String ( \"question du client\" ). getBytes (); DatagramPacket dpE = new DatagramPacket ( bufE , bufE . length , adrDest ); socket . send ( dpE ); System . out . println ( \"Message envoy\u00e9\" ); // Attente de la reponse byte [] bufR = new byte [ 2048 ] ; DatagramPacket dpR = new DatagramPacket ( bufR , bufR . length ); socket . receive ( dpR ); String reponse = new String ( bufR , dpR . getOffset (), dpR . getLength ()); System . out . println ( \"Reponse recue = \" + reponse ); // Fermeture de la socket socket . close (); System . out . println ( \"Arret du client .\" ); } } R\u00e9aliser un serveur UDP en Java package udp ; import java.io.IOException ; import java.net.DatagramPacket ; import java.net.DatagramSocket ; import java.net.InetSocketAddress ; /** * Serveur basique UDP */ public class ServeurUDP { public static void main ( String [] args ) throws Exception { ServeurUDP serveurUDP = new ServeurUDP (); serveurUDP . execute (); } private void execute () throws IOException { // System . out . println ( \"Demarrage du serveur ...\" ); // Le serveur se declare aupres de la couche transport // sur le port 5099 DatagramSocket socket = new DatagramSocket ( null ); socket . bind ( new InetSocketAddress ( 5099 )); // Attente du premier message byte [] bufR = new byte [ 2048 ] ; DatagramPacket dpR = new DatagramPacket ( bufR , bufR . length ); socket . receive ( dpR ); String message = new String ( bufR , dpR . getOffset (), dpR . getLength ()); System . out . println ( \"Message recu = \" + message ); // Emission d'un message en retour byte [] bufE = new String ( \"ok\" ). getBytes (); DatagramPacket dpE = new DatagramPacket ( bufE , bufE . length , dpR . getAddress (), dpR . getPort ()); socket . send ( dpE ); System . out . println ( \"Message envoye = ok\" ); // Fermeture de la socket socket . close (); System . out . println ( \"Arret du serveur .\" ); } } L'API des sockets en Java - TCP \u00b6 R\u00e9aliser un client TCP en Java package tcp ; import java.io.IOException ; import java.io.InputStream ; import java.io.OutputStream ; import java.net.InetSocketAddress ; import java.net.Socket ; /** * Client basique TCP * */ public class ClientTCP { public static void main ( String [] args ) throws Exception { ClientTCP clientTCP = new ClientTCP (); clientTCP . execute (); } /** * Le client cree une socket, envoie un message au serveur * et attend la reponse * */ private void execute () throws IOException { // System . out . println ( \"Demarrage du client ...\" ); //Creation de la socket Socket socket = new Socket (); // Connexion au serveur InetSocketAddress adrDest = new InetSocketAddress ( \"127.0.0.1\" , 5099 ); socket . connect ( adrDest ); // Envoi de la requete byte [] bufE = new String ( \"question du client\" ). getBytes (); OutputStream os = socket . getOutputStream (); os . write ( bufE ); System . out . println ( \"Message envoye\" ); // Attente de la reponse byte [] bufR = new byte [ 2048 ] ; InputStream is = socket . getInputStream (); int lenBufR = is . read ( bufR ); if ( lenBufR !=- 1 ) { String reponse = new String ( bufR , 0 , lenBufR ); System . out . println ( \"Reponse recue = \" + reponse ); } // Fermeture de la socket socket . close (); System . out . println ( \"Arret du client .\" ); } } R\u00e9aliser un serveur TCP en Java package tcp ; import java.io.IOException ; import java.io.InputStream ; import java.io.OutputStream ; import java.net.InetSocketAddress ; import java.net.ServerSocket ; import java.net.Socket ; /** * Serveur basique TCP */ public class ServeurTCP { public static void main ( String [] args ) throws Exception { ServeurTCP serveurTCP = new ServeurTCP (); serveurTCP . execute (); } private void execute () throws IOException { // System . out . println ( \"Demarrage du serveur ...\" ); // Le serveur se declare aupres de la couche transport // sur le port 5099 ServerSocket socketEcoute = new ServerSocket (); socketEcoute . bind ( new InetSocketAddress ( 5099 )); // Attente de la connexion d'un client System . out . println ( \"Attente de la connexion du client ...\" ); Socket socketConnexion = socketEcoute . accept (); // Affichage du port et de l'ip du client System . out . println ( \"Un client est connect\u00e9\" ); System . out . println ( \"IP:\" + socketConnexion . getInetAddress ()); System . out . println ( \"Port:\" + socketConnexion . getPort ()); // Un client s'est connecte, le serveur lit le message envoye par le client (sans garantie de lire tout le message) byte [] bufR = new byte [ 2048 ] ; InputStream is = socketConnexion . getInputStream (); int lenBufR = is . read ( bufR ); if ( lenBufR !=- 1 ) { String message = new String ( bufR , 0 , lenBufR ); System . out . println ( \"Message recu = \" + message ); } // Emission d'un message en retour byte [] bufE = new String ( \"ok\" ). getBytes (); OutputStream os = socketConnexion . getOutputStream (); os . write ( bufE ); System . out . println ( \"Message envoye = ok\" ); // Fermeture de la socket de connexion socketConnexion . close (); // Arret du serveur socketEcoute . close (); System . out . println ( \"Arret du serveur .\" ); } } Les threads en Java \u00b6 L'exemple PingPong vu en cours package thread ; public class PingPong extends Thread { String chaine ; int delai ; public PingPong ( String chaine , int delai ) { super (); this . chaine = chaine ; this . delai = delai ; } public void run () { while ( true ) { System . out . print ( chaine + \" \" ); try { sleep ( delai ); } catch ( InterruptedException e ) { } } } /** * @param args */ public static void main ( String [] args ) { PingPong ping = new PingPong ( \"ping\" , 330 ); PingPong pong = new PingPong ( \"pong\" , 1000 ); ping . start (); pong . start (); } } L'exemple \"Calcul de la constante d'Euler\" vu en cours package thread ; public class Euler extends Thread { long start ; long end ; double res = 0 ; public Euler ( long start , long end ) { this . start = start ; this . end = end ; } public void run () { for ( long i = start ; i <= end ; i ++ ) { res = res + (( double ) 1 ) / ( ( double ) i ); } } /** * @param args */ public static void main ( String [] args ) throws InterruptedException { Euler e1 = new Euler ( 1 , 5000000000l ); Euler e2 = new Euler ( 5000000001l , 10000000000l ); e1 . start (); e2 . start (); e1 . join (); e2 . join (); double euler = e1 . res + e2 . res - Math . log ( 10000000000l ); System . out . println ( \"Euler=\" + euler ); } } Points plus complexes \u00b6 Fermeture de la socket dans un seul sens Partie client import java.io.IOException ; import java.io.InputStream ; import java.io.OutputStream ; import java.net.ServerSocket ; import java.net.Socket ; import java.net.UnknownHostException ; public class ShutDownClient { public static void main ( String [] args ) throws IOException , InterruptedException { ShutDownClient shutDownClient = new ShutDownClient (); shutDownClient . execute (); } private void execute () throws IOException , InterruptedException { // Connection au serveur : on peut voir 3 paquets IP (dialogue ternaire) Socket socket = new Socket ( \"127.0.0.1\" , 2000 ); // Attente de 30 seconces Thread . sleep ( 30_000 ); // Envoi d'un segment TCP toutes les 5 secondes OutputStream os = socket . getOutputStream (); while ( true ) { os . write ( \"xyz\" . getBytes ()); Thread . sleep ( 5000 ); } } } Partie serveur import java.io.IOException ; import java.io.InputStream ; import java.net.ServerSocket ; import java.net.Socket ; public class ShutDownServer { public static void main ( String [] args ) throws IOException , InterruptedException { ShutDownServer shutDownServer = new ShutDownServer (); shutDownServer . execute (); } private void execute () throws IOException , InterruptedException { ServerSocket s = new ServerSocket ( 2000 ); Thread . sleep ( 10_000 ); Socket socket = s . accept (); // Fermeture de la socket , uniquement dans le sens Serveur vers Client socket . shutdownOutput (); // Le serveur peut toujours recevoir des messages du client byte [] buf = new byte [ 1024 ] ; InputStream is = socket . getInputStream (); int len = is . read ( buf ); while ( len !=- 1 ) { String message = new String ( buf , 0 , len ); System . out . println ( \"m=\" + message ); len = is . read ( buf ); } } }","title":"Exemples du cours"},{"location":"exemples/#exemples-du-cours","text":"Voici divers exemples de codes sur les notions vues durant ce cours","title":"Exemples du cours"},{"location":"exemples/#lapi-des-sockets-en-java-udp","text":"R\u00e9aliser un client UDP en Java package udp ; import java.io.IOException ; import java.net.DatagramPacket ; import java.net.DatagramSocket ; import java.net.InetSocketAddress ; /** * Client basique UDP * */ public class ClientUDP { public static void main ( String [] args ) throws Exception { ClientUDP clientUDP = new ClientUDP (); clientUDP . execute (); } /** * Le client cree une socket, envoie un message au serveur * et attend la reponse * */ private void execute () throws IOException { // System . out . println ( \"Demarrage du client ...\" ); //Creation de la socket DatagramSocket socket = new DatagramSocket (); // Creation et envoi du message InetSocketAddress adrDest = new InetSocketAddress ( \"127.0.0.1\" , 5099 ); byte [] bufE = new String ( \"question du client\" ). getBytes (); DatagramPacket dpE = new DatagramPacket ( bufE , bufE . length , adrDest ); socket . send ( dpE ); System . out . println ( \"Message envoy\u00e9\" ); // Attente de la reponse byte [] bufR = new byte [ 2048 ] ; DatagramPacket dpR = new DatagramPacket ( bufR , bufR . length ); socket . receive ( dpR ); String reponse = new String ( bufR , dpR . getOffset (), dpR . getLength ()); System . out . println ( \"Reponse recue = \" + reponse ); // Fermeture de la socket socket . close (); System . out . println ( \"Arret du client .\" ); } } R\u00e9aliser un serveur UDP en Java package udp ; import java.io.IOException ; import java.net.DatagramPacket ; import java.net.DatagramSocket ; import java.net.InetSocketAddress ; /** * Serveur basique UDP */ public class ServeurUDP { public static void main ( String [] args ) throws Exception { ServeurUDP serveurUDP = new ServeurUDP (); serveurUDP . execute (); } private void execute () throws IOException { // System . out . println ( \"Demarrage du serveur ...\" ); // Le serveur se declare aupres de la couche transport // sur le port 5099 DatagramSocket socket = new DatagramSocket ( null ); socket . bind ( new InetSocketAddress ( 5099 )); // Attente du premier message byte [] bufR = new byte [ 2048 ] ; DatagramPacket dpR = new DatagramPacket ( bufR , bufR . length ); socket . receive ( dpR ); String message = new String ( bufR , dpR . getOffset (), dpR . getLength ()); System . out . println ( \"Message recu = \" + message ); // Emission d'un message en retour byte [] bufE = new String ( \"ok\" ). getBytes (); DatagramPacket dpE = new DatagramPacket ( bufE , bufE . length , dpR . getAddress (), dpR . getPort ()); socket . send ( dpE ); System . out . println ( \"Message envoye = ok\" ); // Fermeture de la socket socket . close (); System . out . println ( \"Arret du serveur .\" ); } }","title":"L'API des sockets en Java - UDP"},{"location":"exemples/#lapi-des-sockets-en-java-tcp","text":"R\u00e9aliser un client TCP en Java package tcp ; import java.io.IOException ; import java.io.InputStream ; import java.io.OutputStream ; import java.net.InetSocketAddress ; import java.net.Socket ; /** * Client basique TCP * */ public class ClientTCP { public static void main ( String [] args ) throws Exception { ClientTCP clientTCP = new ClientTCP (); clientTCP . execute (); } /** * Le client cree une socket, envoie un message au serveur * et attend la reponse * */ private void execute () throws IOException { // System . out . println ( \"Demarrage du client ...\" ); //Creation de la socket Socket socket = new Socket (); // Connexion au serveur InetSocketAddress adrDest = new InetSocketAddress ( \"127.0.0.1\" , 5099 ); socket . connect ( adrDest ); // Envoi de la requete byte [] bufE = new String ( \"question du client\" ). getBytes (); OutputStream os = socket . getOutputStream (); os . write ( bufE ); System . out . println ( \"Message envoye\" ); // Attente de la reponse byte [] bufR = new byte [ 2048 ] ; InputStream is = socket . getInputStream (); int lenBufR = is . read ( bufR ); if ( lenBufR !=- 1 ) { String reponse = new String ( bufR , 0 , lenBufR ); System . out . println ( \"Reponse recue = \" + reponse ); } // Fermeture de la socket socket . close (); System . out . println ( \"Arret du client .\" ); } } R\u00e9aliser un serveur TCP en Java package tcp ; import java.io.IOException ; import java.io.InputStream ; import java.io.OutputStream ; import java.net.InetSocketAddress ; import java.net.ServerSocket ; import java.net.Socket ; /** * Serveur basique TCP */ public class ServeurTCP { public static void main ( String [] args ) throws Exception { ServeurTCP serveurTCP = new ServeurTCP (); serveurTCP . execute (); } private void execute () throws IOException { // System . out . println ( \"Demarrage du serveur ...\" ); // Le serveur se declare aupres de la couche transport // sur le port 5099 ServerSocket socketEcoute = new ServerSocket (); socketEcoute . bind ( new InetSocketAddress ( 5099 )); // Attente de la connexion d'un client System . out . println ( \"Attente de la connexion du client ...\" ); Socket socketConnexion = socketEcoute . accept (); // Affichage du port et de l'ip du client System . out . println ( \"Un client est connect\u00e9\" ); System . out . println ( \"IP:\" + socketConnexion . getInetAddress ()); System . out . println ( \"Port:\" + socketConnexion . getPort ()); // Un client s'est connecte, le serveur lit le message envoye par le client (sans garantie de lire tout le message) byte [] bufR = new byte [ 2048 ] ; InputStream is = socketConnexion . getInputStream (); int lenBufR = is . read ( bufR ); if ( lenBufR !=- 1 ) { String message = new String ( bufR , 0 , lenBufR ); System . out . println ( \"Message recu = \" + message ); } // Emission d'un message en retour byte [] bufE = new String ( \"ok\" ). getBytes (); OutputStream os = socketConnexion . getOutputStream (); os . write ( bufE ); System . out . println ( \"Message envoye = ok\" ); // Fermeture de la socket de connexion socketConnexion . close (); // Arret du serveur socketEcoute . close (); System . out . println ( \"Arret du serveur .\" ); } }","title":"L'API des sockets en Java - TCP"},{"location":"exemples/#les-threads-en-java","text":"L'exemple PingPong vu en cours package thread ; public class PingPong extends Thread { String chaine ; int delai ; public PingPong ( String chaine , int delai ) { super (); this . chaine = chaine ; this . delai = delai ; } public void run () { while ( true ) { System . out . print ( chaine + \" \" ); try { sleep ( delai ); } catch ( InterruptedException e ) { } } } /** * @param args */ public static void main ( String [] args ) { PingPong ping = new PingPong ( \"ping\" , 330 ); PingPong pong = new PingPong ( \"pong\" , 1000 ); ping . start (); pong . start (); } } L'exemple \"Calcul de la constante d'Euler\" vu en cours package thread ; public class Euler extends Thread { long start ; long end ; double res = 0 ; public Euler ( long start , long end ) { this . start = start ; this . end = end ; } public void run () { for ( long i = start ; i <= end ; i ++ ) { res = res + (( double ) 1 ) / ( ( double ) i ); } } /** * @param args */ public static void main ( String [] args ) throws InterruptedException { Euler e1 = new Euler ( 1 , 5000000000l ); Euler e2 = new Euler ( 5000000001l , 10000000000l ); e1 . start (); e2 . start (); e1 . join (); e2 . join (); double euler = e1 . res + e2 . res - Math . log ( 10000000000l ); System . out . println ( \"Euler=\" + euler ); } }","title":"Les threads en Java"},{"location":"exemples/#points-plus-complexes","text":"Fermeture de la socket dans un seul sens Partie client import java.io.IOException ; import java.io.InputStream ; import java.io.OutputStream ; import java.net.ServerSocket ; import java.net.Socket ; import java.net.UnknownHostException ; public class ShutDownClient { public static void main ( String [] args ) throws IOException , InterruptedException { ShutDownClient shutDownClient = new ShutDownClient (); shutDownClient . execute (); } private void execute () throws IOException , InterruptedException { // Connection au serveur : on peut voir 3 paquets IP (dialogue ternaire) Socket socket = new Socket ( \"127.0.0.1\" , 2000 ); // Attente de 30 seconces Thread . sleep ( 30_000 ); // Envoi d'un segment TCP toutes les 5 secondes OutputStream os = socket . getOutputStream (); while ( true ) { os . write ( \"xyz\" . getBytes ()); Thread . sleep ( 5000 ); } } } Partie serveur import java.io.IOException ; import java.io.InputStream ; import java.net.ServerSocket ; import java.net.Socket ; public class ShutDownServer { public static void main ( String [] args ) throws IOException , InterruptedException { ShutDownServer shutDownServer = new ShutDownServer (); shutDownServer . execute (); } private void execute () throws IOException , InterruptedException { ServerSocket s = new ServerSocket ( 2000 ); Thread . sleep ( 10_000 ); Socket socket = s . accept (); // Fermeture de la socket , uniquement dans le sens Serveur vers Client socket . shutdownOutput (); // Le serveur peut toujours recevoir des messages du client byte [] buf = new byte [ 1024 ] ; InputStream is = socket . getInputStream (); int len = is . read ( buf ); while ( len !=- 1 ) { String message = new String ( buf , 0 , len ); System . out . println ( \"m=\" + message ); len = is . read ( buf ); } } }","title":"Points plus complexes"},{"location":"intro/","text":"Introduction \u00b6 Ce site contient la liste des TDM du cours NE441, et les exemples du cours.","title":"Introduction"},{"location":"intro/#introduction","text":"Ce site contient la liste des TDM du cours NE441, et les exemples du cours.","title":"Introduction"},{"location":"outils/","text":"Aide Eclipse \u00b6 Durant les TP, nous allons utiliser l'IDE Eclipse pour r\u00e9aliser des programmes Java. Cet outil est \u00e0 la fois puissant et complexe, cette page regroupe des trucs et astuces sur son utilisation. Cr\u00e9er un programme Java dans Eclipse et l'executer \u00b6 Vous lancez Eclipse avec le raccourci en bas \u00e0 gauche. Vous obtenez alors ceci : Vous faites alors File / New / Projet ... , vous obtenez ceci Vous s\u00e9lectionnez Java Project puis Next , vous mettez essai1 par exemple dans Project Name et vous d\u00e9cochez la case \"Create module-info.java file\". Vous obtenez ceci : Ensuite vous faites Finish. Vous obtenez alors la question suivante Vous r\u00e9pondez \"Open perspective\" et vous obtenez : Ensuite vous cliquez sur votre projet essai1, puis vous vous faites clic droit New -> Class Vous saisissez le nom de votre classe (par exemple FirstProgram), puis vous faites Finish. On obtient Vous saisissez votre code : Pour executer votre programme, vous faites clic droit sur votre classe FirstProgram, puis vous faites Run as ... / Java Application Votre programme se lance alors, et vous voyez le r\u00e9sultat dans la console Voir tous les programmes lanc\u00e9s - les stopper \u00b6 Quand vous lancez un programme, celui ci s'execute jusqu'\u00e0 la fin ou jusqu'\u00e0 ce que vous l'arr\u00eatiez. Vous pouvez suivre son \u00e9volution dans la console Pour arr\u00eater un programme, il faut cliquer sur le carr\u00e9 rouge dans la console Pour voir tous les programmes lanc\u00e9s, il faut cliquer sur la fl\u00e9che vers le bas \u00e0 c\u00f4t\u00e9 du pictogramme \"moniteur\" On voit alors la liste de tous les programmes en cours d'ex\u00e9cution (dans cet exemple, il y a 5 programmes en cours d'ex\u00e9cution ) Pour stopper tous les programmes en cours, il faut faire clic droit dans la console, puis \"Terminate / Disconnect all\"","title":"Aide Eclipse"},{"location":"outils/#aide-eclipse","text":"Durant les TP, nous allons utiliser l'IDE Eclipse pour r\u00e9aliser des programmes Java. Cet outil est \u00e0 la fois puissant et complexe, cette page regroupe des trucs et astuces sur son utilisation.","title":"Aide Eclipse"},{"location":"outils/#creer-un-programme-java-dans-eclipse-et-lexecuter","text":"Vous lancez Eclipse avec le raccourci en bas \u00e0 gauche. Vous obtenez alors ceci : Vous faites alors File / New / Projet ... , vous obtenez ceci Vous s\u00e9lectionnez Java Project puis Next , vous mettez essai1 par exemple dans Project Name et vous d\u00e9cochez la case \"Create module-info.java file\". Vous obtenez ceci : Ensuite vous faites Finish. Vous obtenez alors la question suivante Vous r\u00e9pondez \"Open perspective\" et vous obtenez : Ensuite vous cliquez sur votre projet essai1, puis vous vous faites clic droit New -> Class Vous saisissez le nom de votre classe (par exemple FirstProgram), puis vous faites Finish. On obtient Vous saisissez votre code : Pour executer votre programme, vous faites clic droit sur votre classe FirstProgram, puis vous faites Run as ... / Java Application Votre programme se lance alors, et vous voyez le r\u00e9sultat dans la console","title":"Cr\u00e9er un programme Java dans Eclipse et l'executer"},{"location":"outils/#voir-tous-les-programmes-lances-les-stopper","text":"Quand vous lancez un programme, celui ci s'execute jusqu'\u00e0 la fin ou jusqu'\u00e0 ce que vous l'arr\u00eatiez. Vous pouvez suivre son \u00e9volution dans la console Pour arr\u00eater un programme, il faut cliquer sur le carr\u00e9 rouge dans la console Pour voir tous les programmes lanc\u00e9s, il faut cliquer sur la fl\u00e9che vers le bas \u00e0 c\u00f4t\u00e9 du pictogramme \"moniteur\" On voit alors la liste de tous les programmes en cours d'ex\u00e9cution (dans cet exemple, il y a 5 programmes en cours d'ex\u00e9cution ) Pour stopper tous les programmes en cours, il faut faire clic droit dans la console, puis \"Terminate / Disconnect all\"","title":"Voir tous les programmes lanc\u00e9s - les stopper"},{"location":"rappel_reseau/","text":"Rappels r\u00e9seau \u00b6 Vous trouverez ci dessous le chapitre d'introduction du livre \"R\u00e9seaux\" de Andrew Tanenbaum Ce document pr\u00e9sente les notions g\u00e9n\u00e9rales de r\u00e9seaux indispensables pour ce cours TANENBAUM_chap01.pdf Vous trouverez ici un autre document int\u00e9ressant : CMs-Reseaux.pdf","title":"Rappels r\u00e9seau"},{"location":"rappel_reseau/#rappels-reseau","text":"Vous trouverez ci dessous le chapitre d'introduction du livre \"R\u00e9seaux\" de Andrew Tanenbaum Ce document pr\u00e9sente les notions g\u00e9n\u00e9rales de r\u00e9seaux indispensables pour ce cours TANENBAUM_chap01.pdf Vous trouverez ici un autre document int\u00e9ressant : CMs-Reseaux.pdf","title":"Rappels r\u00e9seau"},{"location":"tdm01/","text":"TDM01 \u00b6 Objectifs du TDM num\u00e9ro 1 \u00b6 Le TDM1 va permettre la prise en main de l'API des sockets en JAVA, et r\u00e9aliser des communications entre client et serveur avec UDP. Pour cela, vous devez utiliser Eclipse JAVA sous Linux. Exercice 1 : Echange UDP avec l'outil netcat (avec une seule machine) \u00b6 Lisez la documentation de l'outil netcat. Dans un terminal, lancez la commande man netcat Echangez des messages par UDP depuis une console vers une autre console gr\u00e2ce \u00e0 l'utilitaire netcat : sur une console, vous \u00eates en \u00e9mission de datagrammes UDP vers un port particulier (par exemple : 2000) sur l'autre console, vous \u00eates en r\u00e9ception sur le port 2000 Observez avec wireshark les paquets IP \u00e9chang\u00e9s, et faites l'analogie avec ce que vous avez vu en cours. Question : l'ordre de lancement de netcat dans les deux consoles est il important ? Pourquoi ? Exercice 2 : Echange UDP avec l'outil netcat (avec deux machines) \u00b6 Echangez maintenant des messages par UDP entre deux machines (faites alliance avec un \u00e9tudiant proche de vous!), toujours gr\u00e2ce \u00e0 l'utilitaire netcat : sur une machine, vous \u00eates en \u00e9mission de datagrammes UDP vers un port particulier (par exemple : 2000) et l'adresse IP de l'autre machine sur l'autre machine, vous \u00eates en r\u00e9ception sur le port 2000 Vous pouvez ainsi r\u00e9aliser un syst\u00e8me de \u00ab chat \u00bb entre \u00e9tudiants. Observez avec wireshark les paquets IP \u00e9chang\u00e9s. Exercice 3 : Envoi de datagramme UDP \u00b6 R\u00e9alisez un programme en Java qui envoie un datagramme UDP avec un message simple \u00e0 l'int\u00e9rieur (par exemple le mot \u00ab hello \u00bb), en vous basant sur les exemples fournis sur Chamilo, sur le port 2000 et \u00e0 l'adresse 127.0.0.1. V\u00e9rifiez le bon fonctionnement de votre programme en utilisant netcat pour r\u00e9ceptionner et afficher les datagrammes envoy\u00e9s par votre programme. Exercice 4 : R\u00e9ception de datagramme UDP \u00b6 R\u00e9alisez un programme en Java qui re\u00e7oit les datagrammes UDP sur le port 3000 et l'adresse 127.0.0.1, et qui les affiche \u00e0 l'\u00e9cran ( en vous basant sur les exemples fournis en cours). Votre programme doit afficher le contenu du datagramme, et aussi l'adresse IP et le port de l'\u00e9metteur. V\u00e9rifiez le bon fonctionnement en utilisant netcat pour envoyer des datagrammes vers votre programme, et v\u00e9rifier que l'affichage est bon. Exercice 5 : Envoi / r\u00e9ception de datagramme UDP \u00b6 Faites de nouveau alliance avec un \u00e9tudiant proche de vous, et faites communiquer votre programme de l'exercice 3 sur votre machine avec le programme de l'exercice 4 de l'autre bin\u00f4me sur la machine de l'autre bin\u00f4me. Croisez ensuite en sens inverse. Exercice 6 : Ping Pong en UDP \u00b6 Pr\u00e9sentation \u00b6 Un serveur UDP est lanc\u00e9 sur une machine, ce serveur \u00e9coute en UDP sur le port 29000. Ce serveur fonctionne ainsi : il attend un paquet UDP contenant le texte \u00ab JOUER \u00bb quand il re\u00e7oit ce paquet avec jouer, il r\u00e9pond avec un paquet UDP contenant soit \u00ab PING \u00bb, soit \u00ab PONG \u00bb (de fa\u00e7on al\u00e9atoire) vous devez alors lui renvoyer la balle : si le serveur a dit PING, vous lui renvoyez un paquet UDP avec PONG si le serveur a dit PONG, vous lui renvoyez un paquet UDP avec PING le serveur vous r\u00e9pond \u00ab GAGNE \u00bb ou \u00ab PERDU \u00bb si votre r\u00e9ponse est correcte ou non. L'objectif de cet exercice est de r\u00e9aliser un programme capable de jouer avec ce serveur. Pr\u00e9paration de votre machine. \u00b6 Pour pouvoir tester votre programme, vous allez installer sur votre machine ce serveur UDP. Pour cela, t\u00e9l\u00e9charger le fichier ping-pong.jar ping-pong.jar Placez vous dans le repertoire o\u00f9 vous avez t\u00e9l\u00e9charg\u00e9 ce fichier, et lancez ce serveur UDP avec la commande java -jar ping-pong.jar Vous avez maintenant un serveur UDP \u00e9coutant sur un port 29000. Partie manuelle \u00b6 Faites une partie avec netcat et le serveur fourni. Ecriture du programme \u00b6 Ecrivez maintenant une classe ClientPingPong capable de jouer seule face \u00e0 ce serveur. Votre classe doit faire 10 parties cons\u00e9cutives. Si on ex\u00e9cute le main de cette classe, on obtient l'affichage suivant : =================================== D\u00e9but de la partie 1 Envoi d 'un paquet UDP avec JOUER Le serveur a r\u00e9pondu PING Envoi d' un paquet UDP avec PONG Le serveur a r\u00e9pondu GAGNE Fin de la partie 1 =================================== D\u00e9but de la partie 2 Envoi d 'un paquet UDP avec JOUER Le serveur a r\u00e9pondu PING Envoi d' un paquet UDP avec PONG Le serveur a r\u00e9pondu GAGNE Fin de la partie 2 =================================== D\u00e9but de la partie 3 ... ... Le serveur a r\u00e9pondu GAGNE Fin de la partie 10 Exercice 7 : Table de multiplication UDP \u00b6 Pr\u00e9sentation g\u00e9n\u00e9rale du probl\u00e8me. \u00b6 Un serveur UDP est lanc\u00e9 sur une machine, ce serveur \u00e9coute en UDP sur le port 11000. Ce serveur fonctionne ainsi : il attend un paquet UDP contenant le texte \u00ab JOUER \u00bb quand il re\u00e7oit ce paquet avec JOUER, il r\u00e9pond avec un premier paquet UDP contenant un nombre compris entre 0 et 9 (par exemple 2), puis imm\u00e9diatement apr\u00e8s il envoie \u00e9galement un deuxi\u00e8me paquet UDP contenant un nombre compris entre 0 et 9 (par exemple 8) vous devez alors lui renvoyer le r\u00e9sultat de la multiplication des 2 nombres dans un paquet UDP , c'est \u00e0 dire 16 dans notre exemple, avec un point virgule \u00e0 la fin dans notre exemple, vous devez donc retourner 16; le serveur vous r\u00e9pond \u00ab GAGNE \u00bb ou \u00ab PERDU \u00bb si votre r\u00e9ponse est correcte ou non. L'objectif de cet exercice est de r\u00e9aliser un programme capable de jouer avec ce serveur. Pr\u00e9paration de votre machine \u00b6 Pour pouvoir tester votre programme, vous allez installer sur votre machine ce serveur UDP. Pour cela, t\u00e9l\u00e9charger le fichier multiplication.jar multiplication.jar Lancer ce serveur UDP avec la commande java -jar multiplication.jar Vous avez maintenant un serveur UDP \u00e9coutant sur un port 11000. Partie manuelle \u00b6 Faites une partie avec netcat et le serveur fourni. Ecriture du programme \u00b6 Ecrivez maintenant une classe ClientMultiplication capable de jouer seule face \u00e0 ce serveur. Votre classe doit faire 10 parties cons\u00e9cutives. Si on ex\u00e9cute le main de cette classe, on obtient l'affichage suivant : =========================================== D\u00e9but de la partie 1 Envoi d 'un paquet UDP avec JOUER Le serveur a r\u00e9pondu 9 et 5 Envoi d' un paquet UDP avec 45 ; Le serveur a r\u00e9pondu :GAGNE Fin de la partie 1 =========================================== D\u00e9but de la partie 2 Envoi d 'un paquet UDP avec JOUER \u2026 =========================================== D\u00e9but de la partie 10 Envoi d' un paquet UDP avec JOUER Le serveur a r\u00e9pondu 7 et 2 Envoi d ' un paquet UDP avec 14 ; Le serveur a r\u00e9pondu :GAGNE Fin de la partie 10","title":"TDM01"},{"location":"tdm01/#tdm01","text":"","title":"TDM01"},{"location":"tdm01/#objectifs-du-tdm-numero-1","text":"Le TDM1 va permettre la prise en main de l'API des sockets en JAVA, et r\u00e9aliser des communications entre client et serveur avec UDP. Pour cela, vous devez utiliser Eclipse JAVA sous Linux.","title":"Objectifs du TDM num\u00e9ro 1"},{"location":"tdm01/#exercice-1-echange-udp-avec-loutil-netcat-avec-une-seule-machine","text":"Lisez la documentation de l'outil netcat. Dans un terminal, lancez la commande man netcat Echangez des messages par UDP depuis une console vers une autre console gr\u00e2ce \u00e0 l'utilitaire netcat : sur une console, vous \u00eates en \u00e9mission de datagrammes UDP vers un port particulier (par exemple : 2000) sur l'autre console, vous \u00eates en r\u00e9ception sur le port 2000 Observez avec wireshark les paquets IP \u00e9chang\u00e9s, et faites l'analogie avec ce que vous avez vu en cours. Question : l'ordre de lancement de netcat dans les deux consoles est il important ? Pourquoi ?","title":"Exercice 1\u00a0: Echange UDP avec l'outil netcat (avec une seule machine)"},{"location":"tdm01/#exercice-2-echange-udp-avec-loutil-netcat-avec-deux-machines","text":"Echangez maintenant des messages par UDP entre deux machines (faites alliance avec un \u00e9tudiant proche de vous!), toujours gr\u00e2ce \u00e0 l'utilitaire netcat : sur une machine, vous \u00eates en \u00e9mission de datagrammes UDP vers un port particulier (par exemple : 2000) et l'adresse IP de l'autre machine sur l'autre machine, vous \u00eates en r\u00e9ception sur le port 2000 Vous pouvez ainsi r\u00e9aliser un syst\u00e8me de \u00ab chat \u00bb entre \u00e9tudiants. Observez avec wireshark les paquets IP \u00e9chang\u00e9s.","title":"Exercice 2\u00a0: Echange UDP avec l'outil netcat (avec deux machines)"},{"location":"tdm01/#exercice-3-envoi-de-datagramme-udp","text":"R\u00e9alisez un programme en Java qui envoie un datagramme UDP avec un message simple \u00e0 l'int\u00e9rieur (par exemple le mot \u00ab hello \u00bb), en vous basant sur les exemples fournis sur Chamilo, sur le port 2000 et \u00e0 l'adresse 127.0.0.1. V\u00e9rifiez le bon fonctionnement de votre programme en utilisant netcat pour r\u00e9ceptionner et afficher les datagrammes envoy\u00e9s par votre programme.","title":"Exercice 3\u00a0: Envoi de datagramme UDP"},{"location":"tdm01/#exercice-4-reception-de-datagramme-udp","text":"R\u00e9alisez un programme en Java qui re\u00e7oit les datagrammes UDP sur le port 3000 et l'adresse 127.0.0.1, et qui les affiche \u00e0 l'\u00e9cran ( en vous basant sur les exemples fournis en cours). Votre programme doit afficher le contenu du datagramme, et aussi l'adresse IP et le port de l'\u00e9metteur. V\u00e9rifiez le bon fonctionnement en utilisant netcat pour envoyer des datagrammes vers votre programme, et v\u00e9rifier que l'affichage est bon.","title":"Exercice 4\u00a0: R\u00e9ception de datagramme UDP"},{"location":"tdm01/#exercice-5-envoi-reception-de-datagramme-udp","text":"Faites de nouveau alliance avec un \u00e9tudiant proche de vous, et faites communiquer votre programme de l'exercice 3 sur votre machine avec le programme de l'exercice 4 de l'autre bin\u00f4me sur la machine de l'autre bin\u00f4me. Croisez ensuite en sens inverse.","title":"Exercice 5\u00a0: Envoi / r\u00e9ception de datagramme UDP"},{"location":"tdm01/#exercice-6-ping-pong-en-udp","text":"","title":"Exercice 6 : Ping Pong en UDP"},{"location":"tdm01/#presentation","text":"Un serveur UDP est lanc\u00e9 sur une machine, ce serveur \u00e9coute en UDP sur le port 29000. Ce serveur fonctionne ainsi : il attend un paquet UDP contenant le texte \u00ab JOUER \u00bb quand il re\u00e7oit ce paquet avec jouer, il r\u00e9pond avec un paquet UDP contenant soit \u00ab PING \u00bb, soit \u00ab PONG \u00bb (de fa\u00e7on al\u00e9atoire) vous devez alors lui renvoyer la balle : si le serveur a dit PING, vous lui renvoyez un paquet UDP avec PONG si le serveur a dit PONG, vous lui renvoyez un paquet UDP avec PING le serveur vous r\u00e9pond \u00ab GAGNE \u00bb ou \u00ab PERDU \u00bb si votre r\u00e9ponse est correcte ou non. L'objectif de cet exercice est de r\u00e9aliser un programme capable de jouer avec ce serveur.","title":"Pr\u00e9sentation"},{"location":"tdm01/#preparation-de-votre-machine","text":"Pour pouvoir tester votre programme, vous allez installer sur votre machine ce serveur UDP. Pour cela, t\u00e9l\u00e9charger le fichier ping-pong.jar ping-pong.jar Placez vous dans le repertoire o\u00f9 vous avez t\u00e9l\u00e9charg\u00e9 ce fichier, et lancez ce serveur UDP avec la commande java -jar ping-pong.jar Vous avez maintenant un serveur UDP \u00e9coutant sur un port 29000.","title":"Pr\u00e9paration de votre machine."},{"location":"tdm01/#partie-manuelle","text":"Faites une partie avec netcat et le serveur fourni.","title":"Partie manuelle"},{"location":"tdm01/#ecriture-du-programme","text":"Ecrivez maintenant une classe ClientPingPong capable de jouer seule face \u00e0 ce serveur. Votre classe doit faire 10 parties cons\u00e9cutives. Si on ex\u00e9cute le main de cette classe, on obtient l'affichage suivant : =================================== D\u00e9but de la partie 1 Envoi d 'un paquet UDP avec JOUER Le serveur a r\u00e9pondu PING Envoi d' un paquet UDP avec PONG Le serveur a r\u00e9pondu GAGNE Fin de la partie 1 =================================== D\u00e9but de la partie 2 Envoi d 'un paquet UDP avec JOUER Le serveur a r\u00e9pondu PING Envoi d' un paquet UDP avec PONG Le serveur a r\u00e9pondu GAGNE Fin de la partie 2 =================================== D\u00e9but de la partie 3 ... ... Le serveur a r\u00e9pondu GAGNE Fin de la partie 10","title":"Ecriture du programme"},{"location":"tdm01/#exercice-7-table-de-multiplication-udp","text":"","title":"Exercice 7\u00a0: Table de multiplication UDP"},{"location":"tdm01/#presentation-generale-du-probleme","text":"Un serveur UDP est lanc\u00e9 sur une machine, ce serveur \u00e9coute en UDP sur le port 11000. Ce serveur fonctionne ainsi : il attend un paquet UDP contenant le texte \u00ab JOUER \u00bb quand il re\u00e7oit ce paquet avec JOUER, il r\u00e9pond avec un premier paquet UDP contenant un nombre compris entre 0 et 9 (par exemple 2), puis imm\u00e9diatement apr\u00e8s il envoie \u00e9galement un deuxi\u00e8me paquet UDP contenant un nombre compris entre 0 et 9 (par exemple 8) vous devez alors lui renvoyer le r\u00e9sultat de la multiplication des 2 nombres dans un paquet UDP , c'est \u00e0 dire 16 dans notre exemple, avec un point virgule \u00e0 la fin dans notre exemple, vous devez donc retourner 16; le serveur vous r\u00e9pond \u00ab GAGNE \u00bb ou \u00ab PERDU \u00bb si votre r\u00e9ponse est correcte ou non. L'objectif de cet exercice est de r\u00e9aliser un programme capable de jouer avec ce serveur.","title":"Pr\u00e9sentation g\u00e9n\u00e9rale du probl\u00e8me."},{"location":"tdm01/#preparation-de-votre-machine_1","text":"Pour pouvoir tester votre programme, vous allez installer sur votre machine ce serveur UDP. Pour cela, t\u00e9l\u00e9charger le fichier multiplication.jar multiplication.jar Lancer ce serveur UDP avec la commande java -jar multiplication.jar Vous avez maintenant un serveur UDP \u00e9coutant sur un port 11000.","title":"Pr\u00e9paration de votre machine"},{"location":"tdm01/#partie-manuelle_1","text":"Faites une partie avec netcat et le serveur fourni.","title":"Partie manuelle"},{"location":"tdm01/#ecriture-du-programme_1","text":"Ecrivez maintenant une classe ClientMultiplication capable de jouer seule face \u00e0 ce serveur. Votre classe doit faire 10 parties cons\u00e9cutives. Si on ex\u00e9cute le main de cette classe, on obtient l'affichage suivant : =========================================== D\u00e9but de la partie 1 Envoi d 'un paquet UDP avec JOUER Le serveur a r\u00e9pondu 9 et 5 Envoi d' un paquet UDP avec 45 ; Le serveur a r\u00e9pondu :GAGNE Fin de la partie 1 =========================================== D\u00e9but de la partie 2 Envoi d 'un paquet UDP avec JOUER \u2026 =========================================== D\u00e9but de la partie 10 Envoi d' un paquet UDP avec JOUER Le serveur a r\u00e9pondu 7 et 2 Envoi d ' un paquet UDP avec 14 ; Le serveur a r\u00e9pondu :GAGNE Fin de la partie 10","title":"Ecriture du programme"},{"location":"tdm02/","text":"TDM02 \u00b6 Objectifs du TDM num\u00e9ro 2 \u00b6 Ce TDM va nous montrer comment synchorniser diff\u00e9rents programmes entre eux avec UDP. Exercice 1 : afficher une fen\u00eatre de couleur en JAVA \u00b6 Faites fonctionner le programme suivant : package fr.esisar ; import java.awt.Color ; import javax.swing.JFrame ; public class ColorFrame { public static void main ( String [] args ) throws Exception { ColorFrame c = new ColorFrame (); c . execute (); } private void execute () throws Exception { JFrame frame = new JFrame ( \"Chenillard\" ); frame . setSize ( 300 , 300 ); // frame . getContentPane (). setBackground ( Color . GREEN ); frame . setVisible ( true ); Thread . sleep ( 2000 ); // frame . getContentPane (). setBackground ( Color . RED ); frame . setVisible ( true ); Thread . sleep ( 2000 ); frame . getContentPane (). setBackground ( Color . GREEN ); frame . setVisible ( true ); Thread . sleep ( 2000 ); frame . dispose (); } } Que fait il ? Analyser son fonctionnement interne. Exercice 2 : r\u00e9aliser une \"t\u00e9l\u00e9commande\" avec netcat \u00b6 R\u00e9aliser maintenant un programme Television.java qui affiche au d\u00e9part une fen\u00eatre verte. Ce programme doit \u00eatre pilotable \u00e0 distance avec netcat. La fen\u00eatre verte doit devenir rouge si on envoie la commande \"red\" avec netcat : netcat -u 127 .0.0.1 7050 red La fen\u00eatre doit devenir verte si on envoie la commande \"green\" avec netcat : netcat -u 127 .0.0.1 7050 green Ensuite, au lieu de piloter votre programme local, pilotez un programme distant (sur une autre machine) Exercice 3 : Le ping pong UDP \u00b6 L'objectif de cet exercice est de cr\u00e9er l'effet visuel ci dessous avec deux programmes. Pour faire cela, vous devez faire deux programmes Java (un pour chaque fen\u00eatre). Le programme 1 \u00e9coute sur le port 4001, le programme 2 \u00e9coute sur le port 4002 (en UDP toujours). Le fonctionnement du programme 1 est le suivant : il passe rouge il attend une seconde il passe vert il envoie un message au programme 2 pour lui dire de passer rouge il attend du programme 2 l'ordre de repasser en rouge et ainsi de suite Le fonctionnement du programme 2 est le suivant : il est vert il attend du programme 1 l'ordre de passer en rouge il passe rouge il attend une seconde il passe vert il envoie un message au programme 1 pour lui dire de passer rouge et ainsi de suite On peut consid\u00e9rer que les deux programmes font en quelque sorte une partie de ping pong, en s'\u00e9changeant une balle qui est un message UDP. Exercice 4 : Le ping pong UDP multimachine \u00b6 Maintenant, vous allez faire fonctionner vos deux programmes sur 2 machines diff\u00e9rentes, pour obtenir cet effet visuel : Il sera n\u00e9cessaire de modifier vos programmes pour g\u00e9rer correctement l'IP des machines (\u00e0 la place de 127.0.0.1). Exercice 5 : Le chenillard UDP \u00b6 L'objectif de cet exercice est de cr\u00e9er l'effet visuel ci dessous avec 4 instances d'un m\u00eame programme (c'est \u00e0 dire un programme que vous lancerez 4 fois). La communication entre les instances du programme doit se faire en UDP. Vous devez faire un seul programme, que vous lancerez 4 fois, avec des param\u00e8tres diff\u00e9rents sur la ligne de commande. Exercice 6 : Le chenillard UDP auto adaptatif \u00b6 Dans l'exercice pr\u00e9c\u00e9dent, vous avez not\u00e9 une certaine lourdeur dans l'utilisation de votre chenillard : impossibilit\u00e9 de rajouter facilement un cinqui\u00e8me \u00e9cran, si l'\u00e9cran 3 s'arr\u00eate, alors tout le syst\u00e8me s'arr\u00eate, \u2026 Dans cet exercice, vous allez r\u00e9alisez deux programmes : un programme serveur ordonnanceur un programme client Le programme client sera lanc\u00e9 N fois et correspond \u00e0 un terminal clignotant, le programme serveur sera lanc\u00e9 une seule fois. Le fonctionnement du programme client sera le suivant : d\u00e9marrage du programme il s'enregistre aupr\u00e8s du serveur il attend ensuite les ordres du serveur : un ordre pour passer en rouge, un ordre pour passer en vert Le fonctionnement du programme serveur sera le suivant : il g\u00e8re l'enregistrement des clients les uns apr\u00e8s les autres le dernier client se connecte (pour cela, un param\u00e8tre sur la ligne de commande permet d'indiquer au programme client qu'il est le dernier, le dernier client s'enregistre avec un message sp\u00e9cifique) le programme serveur envoie ensuite les ordres aux clients pour g\u00e9rer correctement l'affichage des couleurs Exercice 7 \u2013 Le chenillard UDP multi machines \u00b6 En vous concertant avec un ou plusieurs autres \u00e9tudiants, r\u00e9alisez un chenillard UDP avec plusieurs machines dans la salle.","title":"TDM02"},{"location":"tdm02/#tdm02","text":"","title":"TDM02"},{"location":"tdm02/#objectifs-du-tdm-numero-2","text":"Ce TDM va nous montrer comment synchorniser diff\u00e9rents programmes entre eux avec UDP.","title":"Objectifs du TDM num\u00e9ro 2"},{"location":"tdm02/#exercice-1-afficher-une-fenetre-de-couleur-en-java","text":"Faites fonctionner le programme suivant : package fr.esisar ; import java.awt.Color ; import javax.swing.JFrame ; public class ColorFrame { public static void main ( String [] args ) throws Exception { ColorFrame c = new ColorFrame (); c . execute (); } private void execute () throws Exception { JFrame frame = new JFrame ( \"Chenillard\" ); frame . setSize ( 300 , 300 ); // frame . getContentPane (). setBackground ( Color . GREEN ); frame . setVisible ( true ); Thread . sleep ( 2000 ); // frame . getContentPane (). setBackground ( Color . RED ); frame . setVisible ( true ); Thread . sleep ( 2000 ); frame . getContentPane (). setBackground ( Color . GREEN ); frame . setVisible ( true ); Thread . sleep ( 2000 ); frame . dispose (); } } Que fait il ? Analyser son fonctionnement interne.","title":"Exercice 1\u00a0: afficher une fen\u00eatre de couleur en JAVA"},{"location":"tdm02/#exercice-2-realiser-une-telecommande-avec-netcat","text":"R\u00e9aliser maintenant un programme Television.java qui affiche au d\u00e9part une fen\u00eatre verte. Ce programme doit \u00eatre pilotable \u00e0 distance avec netcat. La fen\u00eatre verte doit devenir rouge si on envoie la commande \"red\" avec netcat : netcat -u 127 .0.0.1 7050 red La fen\u00eatre doit devenir verte si on envoie la commande \"green\" avec netcat : netcat -u 127 .0.0.1 7050 green Ensuite, au lieu de piloter votre programme local, pilotez un programme distant (sur une autre machine)","title":"Exercice 2\u00a0: r\u00e9aliser une \"t\u00e9l\u00e9commande\" avec netcat"},{"location":"tdm02/#exercice-3-le-ping-pong-udp","text":"L'objectif de cet exercice est de cr\u00e9er l'effet visuel ci dessous avec deux programmes. Pour faire cela, vous devez faire deux programmes Java (un pour chaque fen\u00eatre). Le programme 1 \u00e9coute sur le port 4001, le programme 2 \u00e9coute sur le port 4002 (en UDP toujours). Le fonctionnement du programme 1 est le suivant : il passe rouge il attend une seconde il passe vert il envoie un message au programme 2 pour lui dire de passer rouge il attend du programme 2 l'ordre de repasser en rouge et ainsi de suite Le fonctionnement du programme 2 est le suivant : il est vert il attend du programme 1 l'ordre de passer en rouge il passe rouge il attend une seconde il passe vert il envoie un message au programme 1 pour lui dire de passer rouge et ainsi de suite On peut consid\u00e9rer que les deux programmes font en quelque sorte une partie de ping pong, en s'\u00e9changeant une balle qui est un message UDP.","title":"Exercice 3\u00a0: Le ping pong UDP"},{"location":"tdm02/#exercice-4-le-ping-pong-udp-multimachine","text":"Maintenant, vous allez faire fonctionner vos deux programmes sur 2 machines diff\u00e9rentes, pour obtenir cet effet visuel : Il sera n\u00e9cessaire de modifier vos programmes pour g\u00e9rer correctement l'IP des machines (\u00e0 la place de 127.0.0.1).","title":"Exercice 4\u00a0: Le ping pong UDP multimachine"},{"location":"tdm02/#exercice-5-le-chenillard-udp","text":"L'objectif de cet exercice est de cr\u00e9er l'effet visuel ci dessous avec 4 instances d'un m\u00eame programme (c'est \u00e0 dire un programme que vous lancerez 4 fois). La communication entre les instances du programme doit se faire en UDP. Vous devez faire un seul programme, que vous lancerez 4 fois, avec des param\u00e8tres diff\u00e9rents sur la ligne de commande.","title":"Exercice 5\u00a0: Le chenillard UDP"},{"location":"tdm02/#exercice-6-le-chenillard-udp-auto-adaptatif","text":"Dans l'exercice pr\u00e9c\u00e9dent, vous avez not\u00e9 une certaine lourdeur dans l'utilisation de votre chenillard : impossibilit\u00e9 de rajouter facilement un cinqui\u00e8me \u00e9cran, si l'\u00e9cran 3 s'arr\u00eate, alors tout le syst\u00e8me s'arr\u00eate, \u2026 Dans cet exercice, vous allez r\u00e9alisez deux programmes : un programme serveur ordonnanceur un programme client Le programme client sera lanc\u00e9 N fois et correspond \u00e0 un terminal clignotant, le programme serveur sera lanc\u00e9 une seule fois. Le fonctionnement du programme client sera le suivant : d\u00e9marrage du programme il s'enregistre aupr\u00e8s du serveur il attend ensuite les ordres du serveur : un ordre pour passer en rouge, un ordre pour passer en vert Le fonctionnement du programme serveur sera le suivant : il g\u00e8re l'enregistrement des clients les uns apr\u00e8s les autres le dernier client se connecte (pour cela, un param\u00e8tre sur la ligne de commande permet d'indiquer au programme client qu'il est le dernier, le dernier client s'enregistre avec un message sp\u00e9cifique) le programme serveur envoie ensuite les ordres aux clients pour g\u00e9rer correctement l'affichage des couleurs","title":"Exercice 6\u00a0: Le chenillard UDP auto adaptatif"},{"location":"tdm02/#exercice-7-le-chenillard-udp-multi-machines","text":"En vous concertant avec un ou plusieurs autres \u00e9tudiants, r\u00e9alisez un chenillard UDP avec plusieurs machines dans la salle.","title":"Exercice 7 \u2013 Le chenillard UDP multi machines"},{"location":"tdm03/","text":"TDM03 \u00b6 Objectifs du TDM num\u00e9ro 3 \u00b6 Le TDM3 va permettre la r\u00e9alisation de vos premiers programmes utilisant l'API des sockets pour TCP en JAVA. Exercice 1 : Manipulation avec l'outil netcat \u00b6 Lisez la documentation de l'outil netcat (dans un terminal, faire man netcat). Echangez des messages par TCP depuis une console vers une autre console gr\u00e2ce \u00e0 l'utilitaire netcat : sur une console, vous \u00eates en \u00e9mission TCP vers un port particulier (par exemple : 2000) sur l'autre console, vous \u00eates en r\u00e9ception sur le port 2000 Observez avec wireshark les paquets IP \u00e9chang\u00e9s, et faites l'analogie avec ce que vous avez vu en cours. Question : l'ordre de lancement de netcat dans les deux consoles est il important ? Pourquoi ? Exercice 2 : Envoi de segment TCP avec un programme simple \u00b6 R\u00e9alisez un programme qui : ouvre une socket TCP vers une adresse IP et un port particulier envoie un message simple \u00e0 l'int\u00e9rieur de la socket ferme la connexion d\u00e9s qu'il a envoy\u00e9 les donn\u00e9es, sans lire de r\u00e9ponse en retour. V\u00e9rifiez le bon fonctionnement de votre programme en utilisant netcat pour afficher les donn\u00e9es envoy\u00e9es par votre programme (netcat fera office de serveur TCP). Exercice 3 : R\u00e9ception de segment TCP avec un programme simple \u00b6 R\u00e9alisez un programme qui attend une demande de connexion TCP sur un port particulier affiche \u00e0 l'\u00e9cran le port et l'IP du demandeur de la connexion affiche le contenu de la socket tant que l'\u00e9metteur en envoie V\u00e9rifiez le bon fonctionnement en utilisant netcat pour envoyer des donn\u00e9es vers votre programme, et v\u00e9rifier que l'affichage est correct. En particulier, il faut essayer d'envoyer 4 ou 5 messages en appuyant sur \u00ab Entr\u00e9e \u00bb entre chaque message, et v\u00e9rifier que tous les messages sont affich\u00e9s. Exercice 4 : Lire et interpr\u00e9ter des questions dans un flux TCP \u00b6 Pr\u00e9sentation \u00b6 L'objectif de cet exercice est d'\u00eatre capable d'\u00e9crire un programme capable de lire et d'interpr\u00e9ter des questions dans un flux TCP. Un serveur de jeu est install\u00e9 sur la machine de l'enseignant, le serveur a pour adresse IP 192.168.130.150 et \u00e9coute sur le port 7500 en TCP. Les r\u00e8gles du jeu sont les suivantes vous vous connectez sur le serveur par le biais de netcat apr\u00e8s la connexion, le serveur vous envoie une ou plusieurs questions. 82+12=?72+3=? vous devez r\u00e9pondre \u00e0 ces questions dans l'ordre, en s\u00e9parant les r\u00e9ponses par des points virgules 94;75; le serveur continue ensuite de vous envoyer des questions, et vous devez r\u00e9pondre. A la premi\u00e8re erreur de votre part, le serveur vous affiche votre score sur la partie,le score total de tous les \u00e9tudiants et coupe la connexion. SCORE PARTIE : 2 points SCORE TOTAL 192.198.130.10 : 20 points 192.198.130.30 : 5 points 192.198.130.20 : 2 points Vous devez alors attendre 15 secondes avant d'avoir le droit de rejouer. A noter : si vous r\u00e9pondez correctement en moins de 200 ms, vous gagnez 100 points. si vous r\u00e9pondez correctement en plus de 200 ms, vous gagnez 1 point. Partie manuelle \u00b6 Faites une partie avec netcat et le serveur de jeu. Ecriture du programme \u00b6 Faites maintenant un programme jouant \u00e0 votre place , et obtenez le meilleur score ! Pour manipuler les cha\u00eenes de caract\u00e8res, pensez \u00e0 relire ceci : aide memoire java Finir le TDM chez soi \u00b6 Pour finir le TDM chez vous, vous pouvez installer sur votre machine ce serveur TCP. Pour cela, t\u00e9l\u00e9charger le fichier addition-tcp.jar addition-tcp.jar Placez vous dans le repertoire o\u00f9 vous avez t\u00e9l\u00e9charg\u00e9 ce fichier, et lancez ce serveur TCP avec la commande java -jar addition-tcp.jar","title":"TDM03"},{"location":"tdm03/#tdm03","text":"","title":"TDM03"},{"location":"tdm03/#objectifs-du-tdm-numero-3","text":"Le TDM3 va permettre la r\u00e9alisation de vos premiers programmes utilisant l'API des sockets pour TCP en JAVA.","title":"Objectifs du TDM num\u00e9ro 3"},{"location":"tdm03/#exercice-1-manipulation-avec-loutil-netcat","text":"Lisez la documentation de l'outil netcat (dans un terminal, faire man netcat). Echangez des messages par TCP depuis une console vers une autre console gr\u00e2ce \u00e0 l'utilitaire netcat : sur une console, vous \u00eates en \u00e9mission TCP vers un port particulier (par exemple : 2000) sur l'autre console, vous \u00eates en r\u00e9ception sur le port 2000 Observez avec wireshark les paquets IP \u00e9chang\u00e9s, et faites l'analogie avec ce que vous avez vu en cours. Question : l'ordre de lancement de netcat dans les deux consoles est il important ? Pourquoi ?","title":"Exercice 1\u00a0: Manipulation avec l'outil netcat"},{"location":"tdm03/#exercice-2-envoi-de-segment-tcp-avec-un-programme-simple","text":"R\u00e9alisez un programme qui : ouvre une socket TCP vers une adresse IP et un port particulier envoie un message simple \u00e0 l'int\u00e9rieur de la socket ferme la connexion d\u00e9s qu'il a envoy\u00e9 les donn\u00e9es, sans lire de r\u00e9ponse en retour. V\u00e9rifiez le bon fonctionnement de votre programme en utilisant netcat pour afficher les donn\u00e9es envoy\u00e9es par votre programme (netcat fera office de serveur TCP).","title":"Exercice 2\u00a0: Envoi de segment TCP avec un programme simple"},{"location":"tdm03/#exercice-3-reception-de-segment-tcp-avec-un-programme-simple","text":"R\u00e9alisez un programme qui attend une demande de connexion TCP sur un port particulier affiche \u00e0 l'\u00e9cran le port et l'IP du demandeur de la connexion affiche le contenu de la socket tant que l'\u00e9metteur en envoie V\u00e9rifiez le bon fonctionnement en utilisant netcat pour envoyer des donn\u00e9es vers votre programme, et v\u00e9rifier que l'affichage est correct. En particulier, il faut essayer d'envoyer 4 ou 5 messages en appuyant sur \u00ab Entr\u00e9e \u00bb entre chaque message, et v\u00e9rifier que tous les messages sont affich\u00e9s.","title":"Exercice 3\u00a0: R\u00e9ception de segment TCP avec un programme simple"},{"location":"tdm03/#exercice-4-lire-et-interpreter-des-questions-dans-un-flux-tcp","text":"","title":"Exercice 4\u00a0: Lire et interpr\u00e9ter des questions dans un flux TCP"},{"location":"tdm03/#presentation","text":"L'objectif de cet exercice est d'\u00eatre capable d'\u00e9crire un programme capable de lire et d'interpr\u00e9ter des questions dans un flux TCP. Un serveur de jeu est install\u00e9 sur la machine de l'enseignant, le serveur a pour adresse IP 192.168.130.150 et \u00e9coute sur le port 7500 en TCP. Les r\u00e8gles du jeu sont les suivantes vous vous connectez sur le serveur par le biais de netcat apr\u00e8s la connexion, le serveur vous envoie une ou plusieurs questions. 82+12=?72+3=? vous devez r\u00e9pondre \u00e0 ces questions dans l'ordre, en s\u00e9parant les r\u00e9ponses par des points virgules 94;75; le serveur continue ensuite de vous envoyer des questions, et vous devez r\u00e9pondre. A la premi\u00e8re erreur de votre part, le serveur vous affiche votre score sur la partie,le score total de tous les \u00e9tudiants et coupe la connexion. SCORE PARTIE : 2 points SCORE TOTAL 192.198.130.10 : 20 points 192.198.130.30 : 5 points 192.198.130.20 : 2 points Vous devez alors attendre 15 secondes avant d'avoir le droit de rejouer. A noter : si vous r\u00e9pondez correctement en moins de 200 ms, vous gagnez 100 points. si vous r\u00e9pondez correctement en plus de 200 ms, vous gagnez 1 point.","title":"Pr\u00e9sentation"},{"location":"tdm03/#partie-manuelle","text":"Faites une partie avec netcat et le serveur de jeu.","title":"Partie manuelle"},{"location":"tdm03/#ecriture-du-programme","text":"Faites maintenant un programme jouant \u00e0 votre place , et obtenez le meilleur score ! Pour manipuler les cha\u00eenes de caract\u00e8res, pensez \u00e0 relire ceci : aide memoire java","title":"Ecriture du programme"},{"location":"tdm03/#finir-le-tdm-chez-soi","text":"Pour finir le TDM chez vous, vous pouvez installer sur votre machine ce serveur TCP. Pour cela, t\u00e9l\u00e9charger le fichier addition-tcp.jar addition-tcp.jar Placez vous dans le repertoire o\u00f9 vous avez t\u00e9l\u00e9charg\u00e9 ce fichier, et lancez ce serveur TCP avec la commande java -jar addition-tcp.jar","title":"Finir le TDM chez soi"},{"location":"tdm04/","text":"TDM04 \u00b6 Exercice 1 : Lecture d'un fichier \u00b6 L'objectif de cet exercice est de comprendre le fonctionnement de la lecture d'un fichier sur le syst\u00e8me de fichier. Nous allons illustrer ce fonctionnement par un programme en Java, mais il faut noter que ce fonctionnement est strictement identique en lanage C ou dans un autre langage. Commencez par cr\u00e9er un fichier /home/userir/lecture_fichier.txt avec votre outil favori (vi, nano, ...). Dans ce fichier, vous pouvez placer un texte quelconque, d'une longueur d'au moins 30 caract\u00e8res. Voici maintenant un exemple de code \u00e0 utiliser pour afficher le contenu de votre fichier : import java.io.FileInputStream ; import java.io.IOException ; public class SampleFileReader { public static void main ( String [] args ) throws Exception { SampleFileReader fr = new SampleFileReader (); fr . execute (); } /** * */ private void execute () throws IOException { System . out . println ( \"D\u00e9but lecture du fichier\" ); FileInputStream fis = new FileInputStream ( \"c:/tmp/lecture_fichier.txt\" ); byte [] buf = new byte [ 10 ] ; int len = fis . read ( buf ); while ( len !=- 1 ) { displayBufContent ( buf , len ); len = fis . read ( buf ); } fis . close (); System . out . println ( \"Fin lecture du fichier\" ); } private void displayBufContent ( byte [] buf , int len ) { System . out . println ( \"len=\" + len ); for ( int i = 0 ; i < len ; i ++ ) { System . out . println ( \"Caract\u00e8re lu : \" + buf [ i ] ); } } } Executez cet exemple de code. Ce programme affiche en d\u00e9cimal le code ASCII de chaque caract\u00e8re du fichier. Vous trouverez avec ce lien une table de corresponsance : Tableau ASCII Voici un sch\u00e9ma explicatif sur le transfert des donn\u00e9es vers le buffer : Exercice 2 : Ecriture d'un fichier \u00b6 Nous allons maintenant \u00e9tudier un programme en Java \u00e9crivant dans un fichier. Voici maintenant un exemple de code \u00e0 utiliser pour \u00e9crire le contenu d'un fichier : import java.io.FileOutputStream ; import java.io.IOException ; public class SampleFileWriter { public static void main ( String [] args ) throws Exception { SampleFileWriter fr = new SampleFileWriter (); fr . execute (); } /** * */ private void execute () throws IOException { System . out . println ( \"D\u00e9but \u00e9criture du fichier\" ); FileOutputStream fos = new FileOutputStream ( \"c:/tmp/ecriture_fichier.txt\" ); byte [] buf = new byte [ 10 ] ; buf [ 0 ] = 69 ; buf [ 1 ] = 83 ; buf [ 2 ] = 73 ; buf [ 3 ] = 83 ; buf [ 4 ] = 65 ; buf [ 5 ] = 82 ; // Ecriture des 6 premiers octets du buffer fos . write ( buf , 0 , 6 ); // Fermeture du fichier fos . close (); System . out . println ( \"Fin \u00e9criture du fichier\" ); } } Executez cet exemple de code et \u00e9tudiez le. Exercice 3 :Copie d'un fichier \u00b6 R\u00e9alisez maintenant un programme simple de copie de fichier : votre programme doit copier le fichier /home/userir/file1 vers le fichier /home/userir/file2 Vous devez vous inspirer des deux exemples pr\u00e9c\u00e9dents (utilisez uniquement les classes FileInputStream et FileOutputStream, et uniquement les m\u00e9thodes read, write et close de ces classes). Votre programme doit aussi afficher le temps mis pour r\u00e9aliser la copie. Voici un exemple pour mesurer le temps : long start = System . currentTimeMillis (); // // Your code here // long stop = System . currentTimeMillis (); System . out . println ( \"Elapsed Time = \" + ( stop - start ) + \" ms\" ); Exercice 4 : Test de votre programme de copie de fichiers \u00b6 Cr\u00e9er un fichier de 1Go en utilisant la commande suivante dd if = /dev/urandom of = file1 bs = 1000000 count = 1000 Utiliser le programme de l'exercice 1 pour copier ce fichier de 1Go, et mesurer le temps mis pour faire cette copie. V\u00e9rifier que votre copie est correcte en utilisant l'utilitaire diff. diff file1 file2 Faites maintenant varier la taille du buffer utilis\u00e9 par votre programme (vous testerez avec une taille de buffer de 10,100,1000,10_000,1_000_000). Tracez la courbe du temps mis en fonction de la taille du buffer. Exercice 5 : Transfert de fichier par socket TCP/IP (sans choix du fichier) \u00b6 Ecrire un programme client et un programme serveur qui permettent l'\u00e9change d'un seul fichier (toujours le m\u00eame). Le programme client se connecte au serveur, le serveur retourne au client le contenu du fichier /home/userir/file_serveur.txt (vous pouvez mettre en dur ce nom de fichier dans votre programme serveur). Le programme client sauvegarde le fichier re\u00e7u dans le fichier /home/userir/file_client.txt (vous pouvez mettre en dur ce nom de fichier dans votre programme client). Faites des essais avec un fichier file_serveur.txt de 1Go. Mesurez le temps mis pour le transfert. V\u00e9rifier que votre copie est correcte en utilisant l'utilitaire diff. Exercice 6 : Transfert de fichier par socket TCP/IP (avec choix du fichier) \u00b6 Ecrire un programme client et un programme serveur qui permettent l'\u00e9change de fichier, avec choix du fichier par le client. Le programme client envoie au serveur le nom du fichier qu'il souhaite obtenir. Le serveur retourne au client le fichier demand\u00e9. Le programme client sauvegarde le fichier demand\u00e9 dans le r\u00e9pertoire courant. V\u00e9rifier que votre copie est correcte en utilisant l'utilitaire diff. Attention : le transfert du nom du fichier n'est pas un probl\u00e8me trivial. R\u00e9fl\u00e9chissez \u00e0 la m\u00e9thode qu'il faut utiliser pour savoir que l'on a lu tout le nom du fichier. Exercice 7 : Am\u00e9lioration du transfert de fichiers \u00b6 Modifiez le programme pr\u00e9c\u00e9dent pour faire un affichage de l'avancement du t\u00e9l\u00e9chargement sur le client. Pour cela, il est n\u00e9cessaire que le serveur retourne au client la taille du fichier avant d'envoyer son contenu. Cot\u00e9 serveur, pour conna\u00eetre la taille du fichier, il faut utiliser le code Java suivant : String nomFichier = ...; File f = new File ( nomFichier ); long fileSize = f . length ();","title":"TDM04"},{"location":"tdm04/#tdm04","text":"","title":"TDM04"},{"location":"tdm04/#exercice-1-lecture-dun-fichier","text":"L'objectif de cet exercice est de comprendre le fonctionnement de la lecture d'un fichier sur le syst\u00e8me de fichier. Nous allons illustrer ce fonctionnement par un programme en Java, mais il faut noter que ce fonctionnement est strictement identique en lanage C ou dans un autre langage. Commencez par cr\u00e9er un fichier /home/userir/lecture_fichier.txt avec votre outil favori (vi, nano, ...). Dans ce fichier, vous pouvez placer un texte quelconque, d'une longueur d'au moins 30 caract\u00e8res. Voici maintenant un exemple de code \u00e0 utiliser pour afficher le contenu de votre fichier : import java.io.FileInputStream ; import java.io.IOException ; public class SampleFileReader { public static void main ( String [] args ) throws Exception { SampleFileReader fr = new SampleFileReader (); fr . execute (); } /** * */ private void execute () throws IOException { System . out . println ( \"D\u00e9but lecture du fichier\" ); FileInputStream fis = new FileInputStream ( \"c:/tmp/lecture_fichier.txt\" ); byte [] buf = new byte [ 10 ] ; int len = fis . read ( buf ); while ( len !=- 1 ) { displayBufContent ( buf , len ); len = fis . read ( buf ); } fis . close (); System . out . println ( \"Fin lecture du fichier\" ); } private void displayBufContent ( byte [] buf , int len ) { System . out . println ( \"len=\" + len ); for ( int i = 0 ; i < len ; i ++ ) { System . out . println ( \"Caract\u00e8re lu : \" + buf [ i ] ); } } } Executez cet exemple de code. Ce programme affiche en d\u00e9cimal le code ASCII de chaque caract\u00e8re du fichier. Vous trouverez avec ce lien une table de corresponsance : Tableau ASCII Voici un sch\u00e9ma explicatif sur le transfert des donn\u00e9es vers le buffer :","title":"Exercice 1\u00a0: Lecture d'un fichier"},{"location":"tdm04/#exercice-2-ecriture-dun-fichier","text":"Nous allons maintenant \u00e9tudier un programme en Java \u00e9crivant dans un fichier. Voici maintenant un exemple de code \u00e0 utiliser pour \u00e9crire le contenu d'un fichier : import java.io.FileOutputStream ; import java.io.IOException ; public class SampleFileWriter { public static void main ( String [] args ) throws Exception { SampleFileWriter fr = new SampleFileWriter (); fr . execute (); } /** * */ private void execute () throws IOException { System . out . println ( \"D\u00e9but \u00e9criture du fichier\" ); FileOutputStream fos = new FileOutputStream ( \"c:/tmp/ecriture_fichier.txt\" ); byte [] buf = new byte [ 10 ] ; buf [ 0 ] = 69 ; buf [ 1 ] = 83 ; buf [ 2 ] = 73 ; buf [ 3 ] = 83 ; buf [ 4 ] = 65 ; buf [ 5 ] = 82 ; // Ecriture des 6 premiers octets du buffer fos . write ( buf , 0 , 6 ); // Fermeture du fichier fos . close (); System . out . println ( \"Fin \u00e9criture du fichier\" ); } } Executez cet exemple de code et \u00e9tudiez le.","title":"Exercice 2\u00a0: Ecriture d'un fichier"},{"location":"tdm04/#exercice-3-copie-dun-fichier","text":"R\u00e9alisez maintenant un programme simple de copie de fichier : votre programme doit copier le fichier /home/userir/file1 vers le fichier /home/userir/file2 Vous devez vous inspirer des deux exemples pr\u00e9c\u00e9dents (utilisez uniquement les classes FileInputStream et FileOutputStream, et uniquement les m\u00e9thodes read, write et close de ces classes). Votre programme doit aussi afficher le temps mis pour r\u00e9aliser la copie. Voici un exemple pour mesurer le temps : long start = System . currentTimeMillis (); // // Your code here // long stop = System . currentTimeMillis (); System . out . println ( \"Elapsed Time = \" + ( stop - start ) + \" ms\" );","title":"Exercice 3\u00a0:Copie d'un fichier"},{"location":"tdm04/#exercice-4-test-de-votre-programme-de-copie-de-fichiers","text":"Cr\u00e9er un fichier de 1Go en utilisant la commande suivante dd if = /dev/urandom of = file1 bs = 1000000 count = 1000 Utiliser le programme de l'exercice 1 pour copier ce fichier de 1Go, et mesurer le temps mis pour faire cette copie. V\u00e9rifier que votre copie est correcte en utilisant l'utilitaire diff. diff file1 file2 Faites maintenant varier la taille du buffer utilis\u00e9 par votre programme (vous testerez avec une taille de buffer de 10,100,1000,10_000,1_000_000). Tracez la courbe du temps mis en fonction de la taille du buffer.","title":"Exercice 4\u00a0: Test de votre programme de copie de fichiers"},{"location":"tdm04/#exercice-5-transfert-de-fichier-par-socket-tcpip-sans-choix-du-fichier","text":"Ecrire un programme client et un programme serveur qui permettent l'\u00e9change d'un seul fichier (toujours le m\u00eame). Le programme client se connecte au serveur, le serveur retourne au client le contenu du fichier /home/userir/file_serveur.txt (vous pouvez mettre en dur ce nom de fichier dans votre programme serveur). Le programme client sauvegarde le fichier re\u00e7u dans le fichier /home/userir/file_client.txt (vous pouvez mettre en dur ce nom de fichier dans votre programme client). Faites des essais avec un fichier file_serveur.txt de 1Go. Mesurez le temps mis pour le transfert. V\u00e9rifier que votre copie est correcte en utilisant l'utilitaire diff.","title":"Exercice 5\u00a0: Transfert de fichier par socket TCP/IP (sans choix du fichier)"},{"location":"tdm04/#exercice-6-transfert-de-fichier-par-socket-tcpip-avec-choix-du-fichier","text":"Ecrire un programme client et un programme serveur qui permettent l'\u00e9change de fichier, avec choix du fichier par le client. Le programme client envoie au serveur le nom du fichier qu'il souhaite obtenir. Le serveur retourne au client le fichier demand\u00e9. Le programme client sauvegarde le fichier demand\u00e9 dans le r\u00e9pertoire courant. V\u00e9rifier que votre copie est correcte en utilisant l'utilitaire diff. Attention : le transfert du nom du fichier n'est pas un probl\u00e8me trivial. R\u00e9fl\u00e9chissez \u00e0 la m\u00e9thode qu'il faut utiliser pour savoir que l'on a lu tout le nom du fichier.","title":"Exercice 6\u00a0: Transfert de fichier par socket TCP/IP (avec choix du fichier)"},{"location":"tdm04/#exercice-7-amelioration-du-transfert-de-fichiers","text":"Modifiez le programme pr\u00e9c\u00e9dent pour faire un affichage de l'avancement du t\u00e9l\u00e9chargement sur le client. Pour cela, il est n\u00e9cessaire que le serveur retourne au client la taille du fichier avant d'envoyer son contenu. Cot\u00e9 serveur, pour conna\u00eetre la taille du fichier, il faut utiliser le code Java suivant : String nomFichier = ...; File f = new File ( nomFichier ); long fileSize = f . length ();","title":"Exercice 7\u00a0: Am\u00e9lioration du transfert de fichiers"},{"location":"tdm05/","text":"TDM05 \u00b6 Le TDM 05 va permettre de d\u00e9couvrir la gestion des threads, en Java. Exercice 1 : Calcul de la constante PI^2/6 en mono thread \u00b6 R\u00e9alisez un programme qui calcule la constante PI^2/6 avec la formule suivante, avec N = 2 000 000 000, sans utiliser la notion de thread (programmation classique). Afficher le temps de calcul. Visualisez la consommation de CPU de la machine. Pour cela, il existe divers outils : top vmstat htop L'outil htop est conseill\u00e9 car il permet de visualiser la consommation CPU sur chaque coeur de la machine. Exercice 2 : Calcul de la constante PI^2/6 en multi thread \u00b6 Faites le m\u00eame calcul mais avec un programme avec 2 threads. Afficher le temps de calcul. Visualisez la consommation de CPU de la machine. Faites de m\u00eame avec 4 threads, 8 threads, 16 threads, 32 threads, 512 threads, 1024 threads. Pour chaque cas, afficher le temps de calcul et visualisez la consommation de CPU de la machine. Tracer la courbe du temps de calcul en fonction du nombre de thread (pour tracer la courbe, utilisez Excel ou un autre outil en ligne). Que pouvez vous en conclure ? Exercice 3 : Le probl\u00e8me de la concurrence. \u00b6 Executez le code ci dessous : package tdm.tdm08 ; public class Calculatrice extends Thread { private Somme somme ; public Calculatrice ( Somme somme ) { this . somme = somme ; } @Override public void run () { int res = 0 ; for ( int i = 0 ; i < 1000 ; i ++ ) { res = somme . somme ( res , i ); } System . out . println ( \"La somme 1+2+3+4+...+998+999 est \u00e9gale \u00e0 :\" + res ); } public static void main ( String [] args ) throws InterruptedException { Somme somme = new Somme (); Calculatrice c1 = new Calculatrice ( somme ); Calculatrice c2 = new Calculatrice ( somme ); c1 . start (); c2 . start (); } static class Somme { int c ; public int somme ( int a , int b ) { c = a + b ; System . out . println ( \"c=\" + c ); return c ; } } } Que fait ce code ? Les r\u00e9sultats affich\u00e9s sont ils justes ? Corriger ce code en utilisant les deux m\u00e9thodes vues en cours. Exercice 4 : Somme TCP \u00b6 Pr\u00e9sentation g\u00e9n\u00e9rale du probl\u00e8me. \u00b6 Un serveur TCP est lanc\u00e9 sur une machine, ce serveur \u00e9coute en TCP sur tous les ports compris entre 21 000 et 23 000 (inclus). Ce serveur fonctionne ainsi : le serveur \u00e9coute sur tous les ports compris entre 21 000 et 23 000 (inclus) quand un client se connecte sur un de ces ports, le serveur attend un message contenant le texte COMBIEN quand le serveur re\u00e7u ce message COMBIEN, le serveur r\u00e9pond environ 5 \u00e0 7 secondes plus tard la r\u00e9ponse du serveur est MONTANT=15EURO les textes MONTANT= et EURO sont fixes, par contre la valeur du montant (ici 15) peut varier entre 1 et 10000. une fois la r\u00e9ponse envoy\u00e9e, le serveur ferme la socket de connexion. Le serveur r\u00e9pond \u00ab VOUS AVEZ FAIT UNE ERREUR.\u00bb si le message envoy\u00e9 par le client est diff\u00e9rent de COMBIEN. L'objectif de cet exercice est de r\u00e9aliser un programme capable de d\u00e9terminer : le port X correspondant au montant maximum la valeur du montant maximum la somme des valeurs retourn\u00e9es par chaque port Le programme devra afficher ces 3 valeurs. Pr\u00e9paration de votre machine. \u00b6 Pour pouvoir tester votre programme, vous allez installer sur votre machine ce serveur TCP. Pour cela, t\u00e9l\u00e9charger le fichier somme-tcp.jar somme-tcp.jar Lancer ce serveur avec la commande java -jar somme-tcp.jar Ecriture du programme \u00b6 Ecrivez maintenant une classe SommeTCP. Si on ex\u00e9cute le main de cette classe, on obtient l'affichage suivant : D\u00e9but de la recherche ... Le montant maximum est 8500 euros Le port d ' \u00e9coute correspondant \u00e0 ce maximum est 21500 La somme des montants retourn\u00e9s par tous les ports est 9145123 Fin du programme Cet affichage devra se faire dans un d\u00e9lai inf\u00e9rieur \u00e0 1 minute.","title":"TDM05"},{"location":"tdm05/#tdm05","text":"Le TDM 05 va permettre de d\u00e9couvrir la gestion des threads, en Java.","title":"TDM05"},{"location":"tdm05/#exercice-1-calcul-de-la-constante-pi26-en-mono-thread","text":"R\u00e9alisez un programme qui calcule la constante PI^2/6 avec la formule suivante, avec N = 2 000 000 000, sans utiliser la notion de thread (programmation classique). Afficher le temps de calcul. Visualisez la consommation de CPU de la machine. Pour cela, il existe divers outils : top vmstat htop L'outil htop est conseill\u00e9 car il permet de visualiser la consommation CPU sur chaque coeur de la machine.","title":"Exercice 1\u00a0: Calcul de la constante PI^2/6 en mono thread"},{"location":"tdm05/#exercice-2-calcul-de-la-constante-pi26-en-multi-thread","text":"Faites le m\u00eame calcul mais avec un programme avec 2 threads. Afficher le temps de calcul. Visualisez la consommation de CPU de la machine. Faites de m\u00eame avec 4 threads, 8 threads, 16 threads, 32 threads, 512 threads, 1024 threads. Pour chaque cas, afficher le temps de calcul et visualisez la consommation de CPU de la machine. Tracer la courbe du temps de calcul en fonction du nombre de thread (pour tracer la courbe, utilisez Excel ou un autre outil en ligne). Que pouvez vous en conclure ?","title":"Exercice 2\u00a0: Calcul de la constante PI^2/6 en multi thread"},{"location":"tdm05/#exercice-3-le-probleme-de-la-concurrence","text":"Executez le code ci dessous : package tdm.tdm08 ; public class Calculatrice extends Thread { private Somme somme ; public Calculatrice ( Somme somme ) { this . somme = somme ; } @Override public void run () { int res = 0 ; for ( int i = 0 ; i < 1000 ; i ++ ) { res = somme . somme ( res , i ); } System . out . println ( \"La somme 1+2+3+4+...+998+999 est \u00e9gale \u00e0 :\" + res ); } public static void main ( String [] args ) throws InterruptedException { Somme somme = new Somme (); Calculatrice c1 = new Calculatrice ( somme ); Calculatrice c2 = new Calculatrice ( somme ); c1 . start (); c2 . start (); } static class Somme { int c ; public int somme ( int a , int b ) { c = a + b ; System . out . println ( \"c=\" + c ); return c ; } } } Que fait ce code ? Les r\u00e9sultats affich\u00e9s sont ils justes ? Corriger ce code en utilisant les deux m\u00e9thodes vues en cours.","title":"Exercice 3\u00a0: Le probl\u00e8me de la concurrence."},{"location":"tdm05/#exercice-4-somme-tcp","text":"","title":"Exercice 4\u00a0: Somme TCP"},{"location":"tdm05/#presentation-generale-du-probleme","text":"Un serveur TCP est lanc\u00e9 sur une machine, ce serveur \u00e9coute en TCP sur tous les ports compris entre 21 000 et 23 000 (inclus). Ce serveur fonctionne ainsi : le serveur \u00e9coute sur tous les ports compris entre 21 000 et 23 000 (inclus) quand un client se connecte sur un de ces ports, le serveur attend un message contenant le texte COMBIEN quand le serveur re\u00e7u ce message COMBIEN, le serveur r\u00e9pond environ 5 \u00e0 7 secondes plus tard la r\u00e9ponse du serveur est MONTANT=15EURO les textes MONTANT= et EURO sont fixes, par contre la valeur du montant (ici 15) peut varier entre 1 et 10000. une fois la r\u00e9ponse envoy\u00e9e, le serveur ferme la socket de connexion. Le serveur r\u00e9pond \u00ab VOUS AVEZ FAIT UNE ERREUR.\u00bb si le message envoy\u00e9 par le client est diff\u00e9rent de COMBIEN. L'objectif de cet exercice est de r\u00e9aliser un programme capable de d\u00e9terminer : le port X correspondant au montant maximum la valeur du montant maximum la somme des valeurs retourn\u00e9es par chaque port Le programme devra afficher ces 3 valeurs.","title":"Pr\u00e9sentation g\u00e9n\u00e9rale du probl\u00e8me."},{"location":"tdm05/#preparation-de-votre-machine","text":"Pour pouvoir tester votre programme, vous allez installer sur votre machine ce serveur TCP. Pour cela, t\u00e9l\u00e9charger le fichier somme-tcp.jar somme-tcp.jar Lancer ce serveur avec la commande java -jar somme-tcp.jar","title":"Pr\u00e9paration de votre machine."},{"location":"tdm05/#ecriture-du-programme","text":"Ecrivez maintenant une classe SommeTCP. Si on ex\u00e9cute le main de cette classe, on obtient l'affichage suivant : D\u00e9but de la recherche ... Le montant maximum est 8500 euros Le port d ' \u00e9coute correspondant \u00e0 ce maximum est 21500 La somme des montants retourn\u00e9s par tous les ports est 9145123 Fin du programme Cet affichage devra se faire dans un d\u00e9lai inf\u00e9rieur \u00e0 1 minute.","title":"Ecriture du programme"},{"location":"tdm06/","text":"TDM06 \u00b6 Le TDM 06 va permettre d'approfondir vos connaissances sur la programmation multi thread\u00e9e, en Java. Exercice 1 : Le probl\u00e8me des philosophes - simple \u00b6 Le probl\u00e8me des philosophes est un probl\u00e8me classique invent\u00e9 par le math\u00e9maticien hollandais E Dijskstra, pour tester les algorithmes de synchronisation. N philosophes (N vaut par exemple 5) sont r\u00e9unis autour d'une table dans un restaurant chinois. Chaque philosophe boucle sur deux t\u00e2ches : discuter un temps al\u00e9atoire compris entre 0 et 10 secondes manger un temps al\u00e9atoire compris entre 0 et 10 secondes Faites un premier programme avec 5 thread, chaque thread repr\u00e9sentant un philosophe. Vous afficherez une trace quand un philosophe commence de manger, et quand il commence \u00e0 discuter, avec aussi le num\u00e9ro du philosophe. Faites ensuite le m\u00eame programme avec 50 threads. Exercice 2: Le probl\u00e8me des philosophes avec synchronisation des baguettes \u00b6 Partie 1 : le d\u00e9veloppement \u00b6 Maintenant, on admet que les assiettes sont s\u00e9par\u00e9es de leurs voisines par une baguette seulement. Pour pouvoir manger, un philosophe doit acqu\u00e9rir au pr\u00e9alable les 2 baguettes situ\u00e9es de part et d'autre de son assiette (il est donc en comp\u00e9tition avec ses voisins pour l'obtention des baguettes). Il doit les lib\u00e9rer lorsqu'il se met \u00e0 discuter pour permettre \u00e0 ses voisins de manger \u00e0 leur tour. Le probl\u00e8me consiste \u00e0 synchroniser correctement le comportement des philosophes. La solution envisag\u00e9e consiste \u00e0 disposer d'un arbitre, qui autorisera ou non les philosophes \u00e0 prendre les baguettes. Cr\u00e9ez donc une classe Arbitre avec deux m\u00e9thodes : boolean autorisation(int numPhilo) : un philosophe appellera cette fonction pour savoir si il a le droit de manger. Cette m\u00e9thode retourne true si les deux baguettes sont libres, false sinon void liberation(int numPhilo) : un philosophe appellera cette fonction quand il aura fini de manger, pour indiquer \u00e0 l'arbitre que les baguettes sont maintenant disponibles. Votre classe Philosophe aura donc maintenant le comportement suivant : discuter un temps al\u00e9atoire compris entre 0 et 10 secondes demander les baguettes \u00e0 l'arbitre si l'arbitre r\u00e9pond ok : manger un temps al\u00e9atoire compris entre 0 et 10 secondes puis retourner \u00e0 l'\u00e9tat \u00ab je discute \u00bb puis remanger ... si l'arbitre r\u00e9pond non : attendre 1 seconde, puis demander de nouveau les baguettes \u00e0 l'arbitre. Continuez ainsi jusqu'\u00e0 obtenir les baguettes. Apr\u00e8s avoir mang\u00e9, retourner \u00e0 \u00e0 l'\u00e9tat \u00ab je discute \u00bb puis remanger ... Faites fonctionner le tout. Partie 2 : le test \u00b6 Pour tester si votre code fonctionne, vous devez maintenant supprimer tous les System.out.println() de votre code et passer toutes les attentes \u00e0 1 ms (et avec 50 philosophes). Ensuite, vous devez importer la librairie philo-checker.jar dans votre projet. Pour cela, t\u00e9l\u00e9charger le fichier philo-checker.jar philo-checker.jar puis suivez les consignes suivantes : copier le fichier philo-checker.jar dans le r\u00e9pertoire de votre projet (par exemple /home/userir/eclipse-workspace/TDM06) vous faites clic droit sur votre projet, puis F5 : le fichier philo-checker.jar doit apparaitre dans Eclipse vous faites clic droit sur votre projet, puis \u00ab Properties \u00bb puis Java Build Path, puis Library puis cliquer sur Classpath puis Add Jars puis vous s\u00e9lectionnez philo-checker.jar puis OK Ensuite , vous devez faire les appels suivants dans votre code : CodeChecker . startEating ( numPhilo ); // A inserer \u00e0 l'endroit o\u00f9 votre philosophe commence de manger ... CodeChecker . stopEating ( numPhilo ); // A inserer \u00e0 l'endroit o\u00f9 votre philosophe arr\u00eate de manger Si il y a des erreurs, elles seront affich\u00e9es dans la console. Si il n\u2019y a pas d\u2019erreur, il n\u2019y a pas d\u2019affichage. Exercice 3 : savoir compter ! \u00b6 Vous allez devoir d\u00e9velopper un serveur TCP. Ce serveur \u00e9coute en TCP sur tous les ports compris entre 21 000 et 23 000 (inclus). Ce serveur fonctionne ainsi : le serveur \u00e9coute sur tous les ports compris entre 21 000 et 23 000 (inclus) quand un client se connecte sur un de ces ports, le serveur attend un message contenant le texte NUMERO? quand le serveur a re\u00e7u ce message NUMERO?, il r\u00e9pond NUMERO=12 le texte NUMERO= est fixe, par contre la valeur (ici 12) va s\u2019incr\u00e9menter : le premier client \u00e0 faire une requ\u00eate correcte va recevoir 1 , le deuxi\u00e8me 2 , et ainsi de suite une fois la r\u00e9ponse envoy\u00e9e, le serveur ferme la socket de connexion. Le serveur r\u00e9pond \u00ab VOUS AVEZ FAIT UNE ERREUR.\u00bb si le message envoy\u00e9 par le client est diff\u00e9rent de NUMERO?. La r\u00e9ponse du serveur doit \u00eatre imm\u00e9diate (inf\u00e9rieure \u00e0 1 seconde), quelque soit le nombre de clients qui font des demandes sur les autres ports. Par contre, votre serveur r\u00e9pond \u00e0 un seul client \u00e0 la fois sur un port donn\u00e9. R\u00e9alisez ce serveur TCP et testez le avec le client de test fourni sur Chamilo. Pour cela, t\u00e9l\u00e9charger le fichier compteur-tester.jar compteur-tester.jar Lancer ce client TCP avec la commande java -jar compteur-tester.jar","title":"TDM06"},{"location":"tdm06/#tdm06","text":"Le TDM 06 va permettre d'approfondir vos connaissances sur la programmation multi thread\u00e9e, en Java.","title":"TDM06"},{"location":"tdm06/#exercice-1-le-probleme-des-philosophes-simple","text":"Le probl\u00e8me des philosophes est un probl\u00e8me classique invent\u00e9 par le math\u00e9maticien hollandais E Dijskstra, pour tester les algorithmes de synchronisation. N philosophes (N vaut par exemple 5) sont r\u00e9unis autour d'une table dans un restaurant chinois. Chaque philosophe boucle sur deux t\u00e2ches : discuter un temps al\u00e9atoire compris entre 0 et 10 secondes manger un temps al\u00e9atoire compris entre 0 et 10 secondes Faites un premier programme avec 5 thread, chaque thread repr\u00e9sentant un philosophe. Vous afficherez une trace quand un philosophe commence de manger, et quand il commence \u00e0 discuter, avec aussi le num\u00e9ro du philosophe. Faites ensuite le m\u00eame programme avec 50 threads.","title":"Exercice 1\u00a0: Le probl\u00e8me des philosophes - simple"},{"location":"tdm06/#exercice-2-le-probleme-des-philosophes-avec-synchronisation-des-baguettes","text":"","title":"Exercice 2: Le probl\u00e8me des philosophes avec synchronisation des baguettes"},{"location":"tdm06/#partie-1-le-developpement","text":"Maintenant, on admet que les assiettes sont s\u00e9par\u00e9es de leurs voisines par une baguette seulement. Pour pouvoir manger, un philosophe doit acqu\u00e9rir au pr\u00e9alable les 2 baguettes situ\u00e9es de part et d'autre de son assiette (il est donc en comp\u00e9tition avec ses voisins pour l'obtention des baguettes). Il doit les lib\u00e9rer lorsqu'il se met \u00e0 discuter pour permettre \u00e0 ses voisins de manger \u00e0 leur tour. Le probl\u00e8me consiste \u00e0 synchroniser correctement le comportement des philosophes. La solution envisag\u00e9e consiste \u00e0 disposer d'un arbitre, qui autorisera ou non les philosophes \u00e0 prendre les baguettes. Cr\u00e9ez donc une classe Arbitre avec deux m\u00e9thodes : boolean autorisation(int numPhilo) : un philosophe appellera cette fonction pour savoir si il a le droit de manger. Cette m\u00e9thode retourne true si les deux baguettes sont libres, false sinon void liberation(int numPhilo) : un philosophe appellera cette fonction quand il aura fini de manger, pour indiquer \u00e0 l'arbitre que les baguettes sont maintenant disponibles. Votre classe Philosophe aura donc maintenant le comportement suivant : discuter un temps al\u00e9atoire compris entre 0 et 10 secondes demander les baguettes \u00e0 l'arbitre si l'arbitre r\u00e9pond ok : manger un temps al\u00e9atoire compris entre 0 et 10 secondes puis retourner \u00e0 l'\u00e9tat \u00ab je discute \u00bb puis remanger ... si l'arbitre r\u00e9pond non : attendre 1 seconde, puis demander de nouveau les baguettes \u00e0 l'arbitre. Continuez ainsi jusqu'\u00e0 obtenir les baguettes. Apr\u00e8s avoir mang\u00e9, retourner \u00e0 \u00e0 l'\u00e9tat \u00ab je discute \u00bb puis remanger ... Faites fonctionner le tout.","title":"Partie 1 : le d\u00e9veloppement"},{"location":"tdm06/#partie-2-le-test","text":"Pour tester si votre code fonctionne, vous devez maintenant supprimer tous les System.out.println() de votre code et passer toutes les attentes \u00e0 1 ms (et avec 50 philosophes). Ensuite, vous devez importer la librairie philo-checker.jar dans votre projet. Pour cela, t\u00e9l\u00e9charger le fichier philo-checker.jar philo-checker.jar puis suivez les consignes suivantes : copier le fichier philo-checker.jar dans le r\u00e9pertoire de votre projet (par exemple /home/userir/eclipse-workspace/TDM06) vous faites clic droit sur votre projet, puis F5 : le fichier philo-checker.jar doit apparaitre dans Eclipse vous faites clic droit sur votre projet, puis \u00ab Properties \u00bb puis Java Build Path, puis Library puis cliquer sur Classpath puis Add Jars puis vous s\u00e9lectionnez philo-checker.jar puis OK Ensuite , vous devez faire les appels suivants dans votre code : CodeChecker . startEating ( numPhilo ); // A inserer \u00e0 l'endroit o\u00f9 votre philosophe commence de manger ... CodeChecker . stopEating ( numPhilo ); // A inserer \u00e0 l'endroit o\u00f9 votre philosophe arr\u00eate de manger Si il y a des erreurs, elles seront affich\u00e9es dans la console. Si il n\u2019y a pas d\u2019erreur, il n\u2019y a pas d\u2019affichage.","title":"Partie 2\u00a0: le test"},{"location":"tdm06/#exercice-3-savoir-compter","text":"Vous allez devoir d\u00e9velopper un serveur TCP. Ce serveur \u00e9coute en TCP sur tous les ports compris entre 21 000 et 23 000 (inclus). Ce serveur fonctionne ainsi : le serveur \u00e9coute sur tous les ports compris entre 21 000 et 23 000 (inclus) quand un client se connecte sur un de ces ports, le serveur attend un message contenant le texte NUMERO? quand le serveur a re\u00e7u ce message NUMERO?, il r\u00e9pond NUMERO=12 le texte NUMERO= est fixe, par contre la valeur (ici 12) va s\u2019incr\u00e9menter : le premier client \u00e0 faire une requ\u00eate correcte va recevoir 1 , le deuxi\u00e8me 2 , et ainsi de suite une fois la r\u00e9ponse envoy\u00e9e, le serveur ferme la socket de connexion. Le serveur r\u00e9pond \u00ab VOUS AVEZ FAIT UNE ERREUR.\u00bb si le message envoy\u00e9 par le client est diff\u00e9rent de NUMERO?. La r\u00e9ponse du serveur doit \u00eatre imm\u00e9diate (inf\u00e9rieure \u00e0 1 seconde), quelque soit le nombre de clients qui font des demandes sur les autres ports. Par contre, votre serveur r\u00e9pond \u00e0 un seul client \u00e0 la fois sur un port donn\u00e9. R\u00e9alisez ce serveur TCP et testez le avec le client de test fourni sur Chamilo. Pour cela, t\u00e9l\u00e9charger le fichier compteur-tester.jar compteur-tester.jar Lancer ce client TCP avec la commande java -jar compteur-tester.jar","title":"Exercice 3\u00a0: savoir compter\u00a0!"},{"location":"tdm08/","text":"TDM08 \u00b6 1 Introduction \u00b6 Ce TDM va permettre de d\u00e9couvrir JAVA RMI. RMI (Remote Method Invocation) est une technologie d\u00e9velopp\u00e9e et fournie par JAVA \u00e0 partir du JDK 1.1 pour permettre de mettre en oeuvre facilement des objets distribu\u00e9s. 2 La pr\u00e9sentation et l'architecture de RMI \u00b6 Le but de RMI est de permettre l'appel, l'ex\u00e9cution et le renvoi du r\u00e9sultat d'une m\u00e9thode ex\u00e9cut\u00e9e dans une machine virtuelle diff\u00e9rente de celle de l'objet l'appelant. Cette machine virtuelle peut \u00eatre sur une machine diff\u00e9rente pourvu qu'elle soit accessible par le r\u00e9seau. La machine sur laquelle s'ex\u00e9cute la m\u00e9thode distante est appel\u00e9e serveur. L'appel cot\u00e9 client d'une telle m\u00e9thode est un peu plus compliqu\u00e9 que l'appel d'une m\u00e9thode d'un objet local mais il reste simple. Il consiste \u00e0 obtenir une r\u00e9f\u00e9rence sur l'objet distant puis \u00e0 simplement appeler la m\u00e9thode \u00e0 partir de cette r\u00e9f\u00e9rence. La technologie RMI se charge de rendre transparente la localisation de l'objet distant, son appel et le renvoi du r\u00e9sultat. En fait, elle utilise deux classes particuli\u00e8res, le stub et le skeleton, qui sont g\u00e9n\u00e9r\u00e9es dynamiquement par JAVA. Le stub est une classe qui se situe c\u00f4t\u00e9 client et le skeleton est son homologue cot\u00e9 serveur. Ces deux classes se chargent d'assurer tous les m\u00e9canismes d'appel, de communication, d'ex\u00e9cution, de renvoi et de r\u00e9ception du r\u00e9sultat. Il existe \u00e9galement un RMI Registery, qui m\u00e9morise la liste des serveurs offrant un service. 3 Les diff\u00e9rentes \u00e9tapes pour cr\u00e9er un objet distant et l'appeler avec RMI \u00b6 Le d\u00e9veloppement cot\u00e9 serveur se compose de : La d\u00e9finition d'une interface qui contient les m\u00e9thodes qui peuvent \u00eatre appel\u00e9es \u00e0 distance L'\u00e9criture d'une classe qui impl\u00e9mente cette interface L'\u00e9criture d'une classe qui instanciera l'objet et l'enregistrera en lui affectant un nom dans le registre de noms RMI (RMI Registry) Le cot\u00e9 serveur comprendra \u00e9galement le d\u00e9veloppement du RMI Registry. Le d\u00e9veloppement c\u00f4t\u00e9 client se compose de : L'obtention d'une r\u00e9f\u00e9rence sur l'objet distant \u00e0 partir de son nom L'appel \u00e0 la m\u00e9thode \u00e0 partir de cette r\u00e9f\u00e9rence 4 Le d\u00e9veloppement cot\u00e9 serveur \u00b6 4.1 La d\u00e9finition d'une interface qui contient les m\u00e9thodes de l'objet distant \u00b6 L'interface \u00e0 d\u00e9finir doit h\u00e9riter de l'interface java.rmi.Remote. Cette interface ne contient aucune m\u00e9thode mais indique simplement que l'interface peut \u00eatre appel\u00e9e \u00e0 distance. L'interface doit contenir toutes les m\u00e9thodes qui seront susceptibles d'\u00eatre appel\u00e9es \u00e0 distance. La communication entre le client et le serveur lors de l'invocation de la m\u00e9thode distante peut \u00e9chouer pour diverses raisons telles qu'un crash du serveur, une rupture de la liaison, etc ... Ainsi chaque m\u00e9thode appel\u00e9e \u00e0 distance doit d\u00e9clarer qu'elle est en mesure de lever l'exception java.rmi.RemoteException. Exemple : import java.rmi.Remote ; import java.rmi.RemoteException ; public interface Calculette extends Remote { public int somme ( int a , int b ) throws RemoteException ; } 4.2 L'\u00e9criture d'une classe qui impl\u00e9mente cette interface \u00b6 Cette classe correspond \u00e0 l'objet distant. Elle doit donc impl\u00e9menter l'interface d\u00e9finie et contenir le code n\u00e9cessaire. import java.rmi.RemoteException ; public class CalculetteImpl implements Calculette { public int somme ( int a , int b ) throws RemoteException { System . out . println ( \"Calcul de la somme de \" + a + \" et \" + b ); int c = a + b ; return c ; } } 4.3 L'\u00e9criture d'une classe Server \u00b6 Cette classe Server va permettre d'instancier l'objet, de cr\u00e9er un serveur qui va attendre les demandes et de l'enregistrer dans le registre. import java.rmi.AccessException ; import java.rmi.AlreadyBoundException ; import java.rmi.RemoteException ; import java.rmi.registry.LocateRegistry ; import java.rmi.registry.Registry ; import java.rmi.server.UnicastRemoteObject ; public class CalculetteServer { public static void main ( String [] args ) throws AccessException , RemoteException , AlreadyBoundException { // METTRE ICI L'ADRESSE IP DE VOTRE SERVEUR System . setProperty ( \"java.rmi.server.hostname\" , \"192.168.130.XXX\" ); // Cr\u00e9e un objet r\u00e9el capable de faire des calculs CalculetteImpl calculetteImpl = new CalculetteImpl (); // Cr\u00e9e un serveur ecoutant sur le port 7070, permettant d'acc\u00e9der \u00e0 cet objet r\u00e9el Calculette skeleton = ( Calculette ) UnicastRemoteObject . exportObject ( calculetteImpl , 7070 ); // Il y a un registry sur votre machine sur le port 5050 Registry registry = LocateRegistry . getRegistry ( \"127.0.0.1\" , 5050 ); // On indique au registry qu'un service est pr\u00e9sent sur notre machine, avec son nom registry . bind ( \"calculette\" , skeleton ); System . out . println ( \"Le serveur est pr\u00eat ...\" ); } } 4.4 L'\u00e9criture d'une classe Registry \u00b6 Cette classe va permettre de cr\u00e9er un service RMI Registry, \u00e9coutant sur le port 5050, et m\u00e9morisant la liste des serveurs qui offrent des services. package tp.tp5 ; import java.rmi.AccessException ; import java.rmi.AlreadyBoundException ; import java.rmi.RemoteException ; import java.rmi.registry.LocateRegistry ; import java.rmi.registry.Registry ; public class CreateRegistry { public static void main ( String [] args ) throws AccessException , RemoteException , AlreadyBoundException , InterruptedException { // Il y a un registry sur le port 5050 Registry registry = LocateRegistry . createRegistry ( 5050 ); System . out . println ( \"Le registry est pr\u00eat ...\" ); // Indispensable pour que le registry continue while ( true ) { Thread . sleep ( 100000 ); } } } A noter : pour des raisons obscures, la classe CreateRegistry doit avoir dans son classpath (ou son projet) la classe Caculette. (voir le dernier post de http://stackoverflow.com/questions/27671325/why-does-simple-rmi-server-need-codebase pour comprendre pourquoi en d\u00e9tail). 5 Le d\u00e9veloppement cot\u00e9 client \u00b6 Pour pouvoir utiliser les services propos\u00e9s par CalculetteServer, il faut obtenir une r\u00e9f\u00e9rence sur l'objet distant \u00e0 partir de son nom, et il est ensuite possible d'invoquer une m\u00e9thode sur celui ci. Voici un exemple : package tp.tp5 ; import java.rmi.AccessException ; import java.rmi.AlreadyBoundException ; import java.rmi.NotBoundException ; import java.rmi.RemoteException ; import java.rmi.registry.LocateRegistry ; import java.rmi.registry.Registry ; /** * Programme utilisant les services offerts par CalculetteServer * */ public class UnProgrammeClient { public static void main ( String [] args ) throws AccessException , RemoteException , AlreadyBoundException , NotBoundException { // Il y a un registry sur le port 5050 sur votre machine Registry registry = LocateRegistry . getRegistry ( \"127.0.0.1\" , 5050 ); // On r\u00e9cup\u00e9re un stub qui nous permettra d'acc\u00e9der au service Calculette stub = ( Calculette ) registry . lookup ( \"calculette\" ); // On va maintenant pourvoir s'en servir pour faire un calcul System . out . println ( \"D\u00e9but du programme client\" ); int a = 5 ; int b = 8 ; int c = stub . somme ( a , b ); System . out . println ( \"Le resultat est \" + c ); } } A noter : L'objet retourn\u00e9 \u00e9tant de type Remote, il faut r\u00e9aliser un cast vers l'interface qui d\u00e9finit les m\u00e9thodes de l'objet distant. Un fois le cast r\u00e9alis\u00e9, il suffit simplement d'appeler la m\u00e9thode. 6 D\u00e9tails sur la mise en oeuvre des objets RMI \u00b6 La mise en oeuvre et l'utilisation d'objets distants avec RMI n\u00e9cessite plusieurs \u00e9tapes : D\u00e9marrer le registre RMI sur le serveur en ex\u00e9cutant la classe qui effectue le lancement (dans notre exemple CreateRegistery) Ex\u00e9cuter la classe qui instancie l'objet distant et l'enregistre dans le serveur de noms RMI (dans notre exemple la classe CalculetteServer) Lancer l'application ou l'applet pour tester (dans notre exemple CalculetteClient) 7 Exercice 1 \u2013 RMI , l'exemple classique \u00b6 Mettez en \u0153uvre les explications pr\u00e9c\u00e9dentes : + faites un projet contenant les classes Calculette, CalculetteImpl, CreateRegistry, CalculetteServeur, CalculetteClient + lancer la classe CreateRegistry + lancer la classe CalculetteServeur + lancer la classe CalculetteClient V\u00e9rifiez le fonctionnement de l'ensemble. Analysez les flux r\u00e9seaux avec Wireshark. 8 Exercice 2 \u2013 RMI, la suite \u00b6 Mettez vous par groupe de 2 bin\u00f4mes. Votre poste est client , le poste de l'autre bin\u00f4me est serveur , faites fonctionner cette m\u00e9thode somme \u00e0 distance entre vos deux postes. Analysez les flux r\u00e9seaux avec Wireshark. Ajoutez la m\u00e9thode soustraction \u00e0 l'interface Calculette. Votre poste est toujours client , le poste de l'autre bin\u00f4me est toujours serveur , faites fonctionner cette m\u00e9thode soustraction \u00e0 distance. Analysez les flux r\u00e9seaux avec Wireshark. Exercice 3 \u2013 RMI et le jeu de Nim \u00b6 La version classique du jeu de Nim se joue avec plusieurs tas compos\u00e9s chacun de plusieurs jetons, ou pions, ou allumettes. Chaque joueur \u00e0 son tour peut enlever 1, 2 ou 3 pions, mais dans un seul tas \u00e0 la fois. Le gagnant est celui qui retire le dernier pion. Faites un jeu de Nim en r\u00e9seau gr\u00e2ce \u00e0 RMI. Pour chaque partie, vous aurez donc deux clients et un serveur (chaque client correspondant \u00e0 un joueur).","title":"TDM08"},{"location":"tdm08/#tdm08","text":"","title":"TDM08"},{"location":"tdm08/#1-introduction","text":"Ce TDM va permettre de d\u00e9couvrir JAVA RMI. RMI (Remote Method Invocation) est une technologie d\u00e9velopp\u00e9e et fournie par JAVA \u00e0 partir du JDK 1.1 pour permettre de mettre en oeuvre facilement des objets distribu\u00e9s.","title":"1 Introduction"},{"location":"tdm08/#2-la-presentation-et-larchitecture-de-rmi","text":"Le but de RMI est de permettre l'appel, l'ex\u00e9cution et le renvoi du r\u00e9sultat d'une m\u00e9thode ex\u00e9cut\u00e9e dans une machine virtuelle diff\u00e9rente de celle de l'objet l'appelant. Cette machine virtuelle peut \u00eatre sur une machine diff\u00e9rente pourvu qu'elle soit accessible par le r\u00e9seau. La machine sur laquelle s'ex\u00e9cute la m\u00e9thode distante est appel\u00e9e serveur. L'appel cot\u00e9 client d'une telle m\u00e9thode est un peu plus compliqu\u00e9 que l'appel d'une m\u00e9thode d'un objet local mais il reste simple. Il consiste \u00e0 obtenir une r\u00e9f\u00e9rence sur l'objet distant puis \u00e0 simplement appeler la m\u00e9thode \u00e0 partir de cette r\u00e9f\u00e9rence. La technologie RMI se charge de rendre transparente la localisation de l'objet distant, son appel et le renvoi du r\u00e9sultat. En fait, elle utilise deux classes particuli\u00e8res, le stub et le skeleton, qui sont g\u00e9n\u00e9r\u00e9es dynamiquement par JAVA. Le stub est une classe qui se situe c\u00f4t\u00e9 client et le skeleton est son homologue cot\u00e9 serveur. Ces deux classes se chargent d'assurer tous les m\u00e9canismes d'appel, de communication, d'ex\u00e9cution, de renvoi et de r\u00e9ception du r\u00e9sultat. Il existe \u00e9galement un RMI Registery, qui m\u00e9morise la liste des serveurs offrant un service.","title":"2 La pr\u00e9sentation et l'architecture de RMI"},{"location":"tdm08/#3-les-differentes-etapes-pour-creer-un-objet-distant-et-lappeler-avec-rmi","text":"Le d\u00e9veloppement cot\u00e9 serveur se compose de : La d\u00e9finition d'une interface qui contient les m\u00e9thodes qui peuvent \u00eatre appel\u00e9es \u00e0 distance L'\u00e9criture d'une classe qui impl\u00e9mente cette interface L'\u00e9criture d'une classe qui instanciera l'objet et l'enregistrera en lui affectant un nom dans le registre de noms RMI (RMI Registry) Le cot\u00e9 serveur comprendra \u00e9galement le d\u00e9veloppement du RMI Registry. Le d\u00e9veloppement c\u00f4t\u00e9 client se compose de : L'obtention d'une r\u00e9f\u00e9rence sur l'objet distant \u00e0 partir de son nom L'appel \u00e0 la m\u00e9thode \u00e0 partir de cette r\u00e9f\u00e9rence","title":"3 Les diff\u00e9rentes \u00e9tapes pour cr\u00e9er un objet distant et l'appeler avec RMI"},{"location":"tdm08/#4-le-developpement-cote-serveur","text":"","title":"4 Le d\u00e9veloppement cot\u00e9 serveur"},{"location":"tdm08/#41-la-definition-dune-interface-qui-contient-les-methodes-de-lobjet-distant","text":"L'interface \u00e0 d\u00e9finir doit h\u00e9riter de l'interface java.rmi.Remote. Cette interface ne contient aucune m\u00e9thode mais indique simplement que l'interface peut \u00eatre appel\u00e9e \u00e0 distance. L'interface doit contenir toutes les m\u00e9thodes qui seront susceptibles d'\u00eatre appel\u00e9es \u00e0 distance. La communication entre le client et le serveur lors de l'invocation de la m\u00e9thode distante peut \u00e9chouer pour diverses raisons telles qu'un crash du serveur, une rupture de la liaison, etc ... Ainsi chaque m\u00e9thode appel\u00e9e \u00e0 distance doit d\u00e9clarer qu'elle est en mesure de lever l'exception java.rmi.RemoteException. Exemple : import java.rmi.Remote ; import java.rmi.RemoteException ; public interface Calculette extends Remote { public int somme ( int a , int b ) throws RemoteException ; }","title":"4.1 La d\u00e9finition d'une interface qui contient les m\u00e9thodes de l'objet distant"},{"location":"tdm08/#42-lecriture-dune-classe-qui-implemente-cette-interface","text":"Cette classe correspond \u00e0 l'objet distant. Elle doit donc impl\u00e9menter l'interface d\u00e9finie et contenir le code n\u00e9cessaire. import java.rmi.RemoteException ; public class CalculetteImpl implements Calculette { public int somme ( int a , int b ) throws RemoteException { System . out . println ( \"Calcul de la somme de \" + a + \" et \" + b ); int c = a + b ; return c ; } }","title":"4.2  L'\u00e9criture d'une classe qui impl\u00e9mente cette interface"},{"location":"tdm08/#43-lecriture-dune-classe-server","text":"Cette classe Server va permettre d'instancier l'objet, de cr\u00e9er un serveur qui va attendre les demandes et de l'enregistrer dans le registre. import java.rmi.AccessException ; import java.rmi.AlreadyBoundException ; import java.rmi.RemoteException ; import java.rmi.registry.LocateRegistry ; import java.rmi.registry.Registry ; import java.rmi.server.UnicastRemoteObject ; public class CalculetteServer { public static void main ( String [] args ) throws AccessException , RemoteException , AlreadyBoundException { // METTRE ICI L'ADRESSE IP DE VOTRE SERVEUR System . setProperty ( \"java.rmi.server.hostname\" , \"192.168.130.XXX\" ); // Cr\u00e9e un objet r\u00e9el capable de faire des calculs CalculetteImpl calculetteImpl = new CalculetteImpl (); // Cr\u00e9e un serveur ecoutant sur le port 7070, permettant d'acc\u00e9der \u00e0 cet objet r\u00e9el Calculette skeleton = ( Calculette ) UnicastRemoteObject . exportObject ( calculetteImpl , 7070 ); // Il y a un registry sur votre machine sur le port 5050 Registry registry = LocateRegistry . getRegistry ( \"127.0.0.1\" , 5050 ); // On indique au registry qu'un service est pr\u00e9sent sur notre machine, avec son nom registry . bind ( \"calculette\" , skeleton ); System . out . println ( \"Le serveur est pr\u00eat ...\" ); } }","title":"4.3 L'\u00e9criture d'une classe Server"},{"location":"tdm08/#44-lecriture-dune-classe-registry","text":"Cette classe va permettre de cr\u00e9er un service RMI Registry, \u00e9coutant sur le port 5050, et m\u00e9morisant la liste des serveurs qui offrent des services. package tp.tp5 ; import java.rmi.AccessException ; import java.rmi.AlreadyBoundException ; import java.rmi.RemoteException ; import java.rmi.registry.LocateRegistry ; import java.rmi.registry.Registry ; public class CreateRegistry { public static void main ( String [] args ) throws AccessException , RemoteException , AlreadyBoundException , InterruptedException { // Il y a un registry sur le port 5050 Registry registry = LocateRegistry . createRegistry ( 5050 ); System . out . println ( \"Le registry est pr\u00eat ...\" ); // Indispensable pour que le registry continue while ( true ) { Thread . sleep ( 100000 ); } } } A noter : pour des raisons obscures, la classe CreateRegistry doit avoir dans son classpath (ou son projet) la classe Caculette. (voir le dernier post de http://stackoverflow.com/questions/27671325/why-does-simple-rmi-server-need-codebase pour comprendre pourquoi en d\u00e9tail).","title":"4.4  L'\u00e9criture d'une classe Registry"},{"location":"tdm08/#5-le-developpement-cote-client","text":"Pour pouvoir utiliser les services propos\u00e9s par CalculetteServer, il faut obtenir une r\u00e9f\u00e9rence sur l'objet distant \u00e0 partir de son nom, et il est ensuite possible d'invoquer une m\u00e9thode sur celui ci. Voici un exemple : package tp.tp5 ; import java.rmi.AccessException ; import java.rmi.AlreadyBoundException ; import java.rmi.NotBoundException ; import java.rmi.RemoteException ; import java.rmi.registry.LocateRegistry ; import java.rmi.registry.Registry ; /** * Programme utilisant les services offerts par CalculetteServer * */ public class UnProgrammeClient { public static void main ( String [] args ) throws AccessException , RemoteException , AlreadyBoundException , NotBoundException { // Il y a un registry sur le port 5050 sur votre machine Registry registry = LocateRegistry . getRegistry ( \"127.0.0.1\" , 5050 ); // On r\u00e9cup\u00e9re un stub qui nous permettra d'acc\u00e9der au service Calculette stub = ( Calculette ) registry . lookup ( \"calculette\" ); // On va maintenant pourvoir s'en servir pour faire un calcul System . out . println ( \"D\u00e9but du programme client\" ); int a = 5 ; int b = 8 ; int c = stub . somme ( a , b ); System . out . println ( \"Le resultat est \" + c ); } } A noter : L'objet retourn\u00e9 \u00e9tant de type Remote, il faut r\u00e9aliser un cast vers l'interface qui d\u00e9finit les m\u00e9thodes de l'objet distant. Un fois le cast r\u00e9alis\u00e9, il suffit simplement d'appeler la m\u00e9thode.","title":"5  Le d\u00e9veloppement cot\u00e9 client"},{"location":"tdm08/#6-details-sur-la-mise-en-oeuvre-des-objets-rmi","text":"La mise en oeuvre et l'utilisation d'objets distants avec RMI n\u00e9cessite plusieurs \u00e9tapes : D\u00e9marrer le registre RMI sur le serveur en ex\u00e9cutant la classe qui effectue le lancement (dans notre exemple CreateRegistery) Ex\u00e9cuter la classe qui instancie l'objet distant et l'enregistre dans le serveur de noms RMI (dans notre exemple la classe CalculetteServer) Lancer l'application ou l'applet pour tester (dans notre exemple CalculetteClient)","title":"6  D\u00e9tails sur la mise en oeuvre des objets RMI"},{"location":"tdm08/#7-exercice-1-rmi-lexemple-classique","text":"Mettez en \u0153uvre les explications pr\u00e9c\u00e9dentes : + faites un projet contenant les classes Calculette, CalculetteImpl, CreateRegistry, CalculetteServeur, CalculetteClient + lancer la classe CreateRegistry + lancer la classe CalculetteServeur + lancer la classe CalculetteClient V\u00e9rifiez le fonctionnement de l'ensemble. Analysez les flux r\u00e9seaux avec Wireshark.","title":"7  Exercice 1 \u2013 RMI , l'exemple classique"},{"location":"tdm08/#8-exercice-2-rmi-la-suite","text":"Mettez vous par groupe de 2 bin\u00f4mes. Votre poste est client , le poste de l'autre bin\u00f4me est serveur , faites fonctionner cette m\u00e9thode somme \u00e0 distance entre vos deux postes. Analysez les flux r\u00e9seaux avec Wireshark. Ajoutez la m\u00e9thode soustraction \u00e0 l'interface Calculette. Votre poste est toujours client , le poste de l'autre bin\u00f4me est toujours serveur , faites fonctionner cette m\u00e9thode soustraction \u00e0 distance. Analysez les flux r\u00e9seaux avec Wireshark.","title":"8  Exercice 2 \u2013 RMI, la suite"},{"location":"tdm08/#exercice-3-rmi-et-le-jeu-de-nim","text":"La version classique du jeu de Nim se joue avec plusieurs tas compos\u00e9s chacun de plusieurs jetons, ou pions, ou allumettes. Chaque joueur \u00e0 son tour peut enlever 1, 2 ou 3 pions, mais dans un seul tas \u00e0 la fois. Le gagnant est celui qui retire le dernier pion. Faites un jeu de Nim en r\u00e9seau gr\u00e2ce \u00e0 RMI. Pour chaque partie, vous aurez donc deux clients et un serveur (chaque client correspondant \u00e0 un joueur).","title":"Exercice 3 \u2013 RMI et le jeu de Nim"},{"location":"tdm09/","text":"TDM09 \u00b6 Exercice 1 : copie de fichiers \u00b6 T\u00e9l\u00e9chargez l'image ci dessous et sauvegardez la dans un fichier nomm\u00e9 esisar.bmp. Copier maintenant le code ci dessous dans Eclipse, et ex\u00e9cutez le : import java.io.FileInputStream ; import java.io.FileOutputStream ; import java.io.IOException ; public class CopyFile { public static void main ( String [] args ) throws IOException { String fromFile = \"esisar.bmp\" ; String toFile = \"esisar2.bmp\" ; System . out . println ( \"Debut de la copie de \" + fromFile + \" vers \" + toFile ); FileInputStream fis = new FileInputStream ( fromFile ); byte [] bs = new byte [ 64 * 1024 ] ; int len = 0 ; String str = \"\" ; while ( len != - 1 ) { str = str + new String ( bs , 0 , len ); len = fis . read ( bs ); } fis . close (); FileOutputStream fos = new FileOutputStream ( toFile ); fos . write ( str . getBytes ()); fos . close (); System . out . println ( \"Fin de la copie\" ); } } Ouvrez maintenant le fichier esisar2.bmp avec un visualisateur d'image (par exemple Firefox), que constatez vous ? Faites maintenant la m\u00eame op\u00e9ration de copie avec un autre fichier , avez vous le m\u00eame probl\u00e8me ? Question 1 \u00b6 D\u00e9terminez ce qui provoque la modification du fichier. Question 2 (optionnelle - difficile ) \u00b6 Cr\u00e9er un fichier esisar.bmp dont le rendu initial est \"ESISAR\", et dont le rendu apr\u00e8s copie est \"ESISAR P2026\". Exercice 2 : Envoi de fichier par un serveur multi thread\u00e9 \u00b6 Reprendre le programme de l'exercice 5 du TDM04 ( transfert de fichier par socket TCP/IP avec visualisation de l'avancement). Modifiez le programme c\u00f4t\u00e9 serveur pour qu'il supporte le t\u00e9l\u00e9chargement de plusieurs fichiers en simultan\u00e9. Vous r\u00e9aliserez un serveur multi thread\u00e9 avec cr\u00e9ation d'un nouveau thread \u00e0 chaque nouvelle connexion. Faites des essais avec des fichiers de grande taille et en mettant en temps d'attente cote client, pour v\u00e9rifier s'il est bien possible de t\u00e9l\u00e9charger plusieurs fichiers de fa\u00e7on simultan\u00e9e.","title":"TDM09"},{"location":"tdm09/#tdm09","text":"","title":"TDM09"},{"location":"tdm09/#exercice-1-copie-de-fichiers","text":"T\u00e9l\u00e9chargez l'image ci dessous et sauvegardez la dans un fichier nomm\u00e9 esisar.bmp. Copier maintenant le code ci dessous dans Eclipse, et ex\u00e9cutez le : import java.io.FileInputStream ; import java.io.FileOutputStream ; import java.io.IOException ; public class CopyFile { public static void main ( String [] args ) throws IOException { String fromFile = \"esisar.bmp\" ; String toFile = \"esisar2.bmp\" ; System . out . println ( \"Debut de la copie de \" + fromFile + \" vers \" + toFile ); FileInputStream fis = new FileInputStream ( fromFile ); byte [] bs = new byte [ 64 * 1024 ] ; int len = 0 ; String str = \"\" ; while ( len != - 1 ) { str = str + new String ( bs , 0 , len ); len = fis . read ( bs ); } fis . close (); FileOutputStream fos = new FileOutputStream ( toFile ); fos . write ( str . getBytes ()); fos . close (); System . out . println ( \"Fin de la copie\" ); } } Ouvrez maintenant le fichier esisar2.bmp avec un visualisateur d'image (par exemple Firefox), que constatez vous ? Faites maintenant la m\u00eame op\u00e9ration de copie avec un autre fichier , avez vous le m\u00eame probl\u00e8me ?","title":"Exercice 1 : copie de fichiers"},{"location":"tdm09/#question-1","text":"D\u00e9terminez ce qui provoque la modification du fichier.","title":"Question 1"},{"location":"tdm09/#question-2-optionnelle-difficile","text":"Cr\u00e9er un fichier esisar.bmp dont le rendu initial est \"ESISAR\", et dont le rendu apr\u00e8s copie est \"ESISAR P2026\".","title":"Question 2 (optionnelle - difficile )"},{"location":"tdm09/#exercice-2-envoi-de-fichier-par-un-serveur-multi-threade","text":"Reprendre le programme de l'exercice 5 du TDM04 ( transfert de fichier par socket TCP/IP avec visualisation de l'avancement). Modifiez le programme c\u00f4t\u00e9 serveur pour qu'il supporte le t\u00e9l\u00e9chargement de plusieurs fichiers en simultan\u00e9. Vous r\u00e9aliserez un serveur multi thread\u00e9 avec cr\u00e9ation d'un nouveau thread \u00e0 chaque nouvelle connexion. Faites des essais avec des fichiers de grande taille et en mettant en temps d'attente cote client, pour v\u00e9rifier s'il est bien possible de t\u00e9l\u00e9charger plusieurs fichiers de fa\u00e7on simultan\u00e9e.","title":"Exercice 2\u00a0: Envoi de fichier par un serveur multi thread\u00e9"},{"location":"tdm10/","text":"TDM10 \u00b6 Objectifs du TDM \u00b6 Ce TDM va permettre la d\u00e9couverte (ou r\u00e9vision) du protocole HTTP. Exercice 1 : R\u00e9vision HTTP avec netcat \u00b6 Le protocole HTTP fonctionne au dessus du protocole TCP, il permet de manipuler des ressources distantes. Il est principalement utilis\u00e9 pour le web. Le client envoie des requ\u00eates avec le format suivant : Ligne de commande ( Commande, URL, Version de protocole ) En-t\u00eate de requ\u00eates [ Ligne vide ] Corps de requ\u00eate La ligne de commande indique ce que le client attend. Par exemple, pour obtenir la page d'accueil, on utilisera la commande : GET /index.html HTTP/1.1 Host : 192 .168.130.214 Connection: close [ Ligne vide ] L'ent\u00eate de requ\u00eate contient une succession de couples ( variable : valeur) , par exemple Host : 192.168.130.214. Elle permet au client de donner des informations \u00e0 son propos ou de pr\u00e9ciser la requ\u00eate. La ligne vide est tr\u00e8s importante elle distingue le header HTTP du reste du message. Le corps de la requ\u00eate peut contenir des donn\u00e9es additionnelles (dans le cas de messages POST par exemple) Le serveur r\u00e9pond avec un format similaire : Ligne de statut ( Version, Code r\u00e9ponse, Texte r\u00e9ponse ) En-t\u00eate de r\u00e9ponse [ Ligne vide ] Corps de r\u00e9ponse La ligne de status indique au client si sa requ\u00eate a r\u00e9ussi. Parmi les r\u00e9ponses possibles: HTTP/1.0 200 OK indique le succ\u00e8s de l'op\u00e9ration HTTP/1.0 404 Not Found, indique que la page demand\u00e9 n'existe pas. HTTP/1.0 418 I'm a teapot, indique que le serveur n'est pas un serveur HTTP mais une th\u00e9i\u00e8re (RFC 2324). L'ent\u00eate permet au serveur de pr\u00e9ciser la r\u00e9ponse par exemple en indiquant la taille et le type de la ressource demand\u00e9e. La ligne vide s\u00e9pare l'ent\u00eate de la ressource demand\u00e9e dans le corps du message. Naviguez sur le serveur de la salle avec un navigateur classique. L'URL est http://192.168.130.214/index.html Faites ensuite la m\u00eame navigation avec l'utilitaire netcat, en tapant directement \u00e0 la main les commandes HTTP (vous utiliserez le protocole HTTP/1.1). Prenez le temps de bien observer le contenu des \u00e9changes, et de comprendre comment fonctionne votre navigateur Web : combien de requ\u00eates HTTP doit il faire pour afficher une page, ...? Exercice 2 : D\u00e9couverte du JavaScript \u00b6 Naviguez sur le serveur de la salle avec un navigateur classique, pour charger la page http://192.168.130.214/on_load.html Afficher le code source de page (faire clic droit dans le navigateur, view page source) Afficher le DOM apr\u00e8s l'\u00e9x\u00e9cution du Javascript (faire clic droit dans le navigateur, inspect) Coment se passe le chargement d'une page WEB ? Exercice 3 : Suite JavaScript \u00b6 Naviguez sur le serveur de la salle avec un navigateur classique, pour charger la page http://192.168.130.214/button.html Afficher le code source de page (faire clic droit dans le navigateur, view page source) Afficher le DOM apr\u00e8s l'\u00e9x\u00e9cution du Javascript (faire clic droit dans le navigateur, inspect) Cliquer ensuite sur le bouton \"Click me\" de la page WEB Afficher le code source de page (faire clic droit dans le navigateur, view page source) Afficher le DOM apr\u00e8s l'\u00e9x\u00e9cution du Javascript (faire clic droit dans le navigateur, inspect) Faites maintenant une recherche internet pour en savoir sur les SPA : Single Page Application MPA : Mulptiple Page Application Exercice 4 : R\u00e9alisation d'un client HTTP avec extraction de flux vid\u00e9o \u00b6 T\u00e9l\u00e9charger le fichier http-image.jar http-image.jar Placez vous dans le repertoire o\u00f9 vous avez t\u00e9l\u00e9charg\u00e9 ce fichier, et lancez ce serveur HTTP avec la commande java -jar http-image.jar Ensuite, lancez un navigateur WEB sur l'url http://127.0.0.1:8000 Observez la page qui s'affiche. Cette technique est notamment utilis\u00e9e par les WEBCAM. Faites du reverse engineering avec wireshark pour voir le flux qui est envoy\u00e9. D\u00e9veloppez maintenant un client Java qui interroge ce client HTTP, et qui est capable d'extraire les images envoy\u00e9es et de les sauvegarder dans des fichiers (par image01.bmp, image02.bmp, ...) Exercice 5 : R\u00e9alisation d'un serveur HTTP avec flux vid\u00e9o \u00b6 D\u00e9veloppez ensuite votre propre serveur HTTP qui aura un rendu similaire \u00e0 celui fourni. Pour cr\u00e9er une image bitmap, vous pouvez utiliser les deux classes Java BufferedImage et ImageIO (ces deux classes sont comprises dans le langage Java de base et permettent la cr\u00e9ation d'image au format BMP ou autre). Exercice 6 : R\u00e9alisation d'une balle rebondissante multi \u00e9crans \u00b6 D\u00e9veloppez maintenant votre propre serveur HTTP, qui fourni un flux vid\u00e9o avec une balle redondissante \u00e0 l'int\u00e9rieur. Si deux navigateurs sont connect\u00e9s \u00e0 votre serveur, alors la balle doit rebondir entre les deux navigateurs. Exercice 7 : R\u00e9alisation d'un serveur HTTP de fichiers \u00b6 Vous allez maintenant r\u00e9aliser un serveur HTTP, qui affiche une page d'accueil et une autre page permettant de t\u00e9l\u00e9charger des fichiers. R\u00e9aliser un serveur TCP qui \u00e9coute les connexions entrantes, et qui v\u00e9rifie que la requ\u00eate commence par le mot GET . Si la page demand\u00e9e est /index.html, alors votre serveur renvoie une page fixe (vous afficherez par exemple simplement une page HTML avec le message \u00ab Bonjour \u00bb). Si la page demand\u00e9e est /fichiers.html, alors votre serveur renvoie une page avec la liste des fichiers disponibles au t\u00e9l\u00e9chargement, et il est possible de cliquer sur un lien pour lancer le t\u00e9l\u00e9chargement. Tester votre serveur avec un navigateur web en demandant la page \" http://localhost:port/index.html \" o\u00f9 port est le port d'\u00e9coute de votre serveur. V\u00e9rifier que le t\u00e9l\u00e9chargement des fichiers se d\u00e9roule correctement.","title":"TDM10"},{"location":"tdm10/#tdm10","text":"","title":"TDM10"},{"location":"tdm10/#objectifs-du-tdm","text":"Ce TDM va permettre la d\u00e9couverte (ou r\u00e9vision) du protocole HTTP.","title":"Objectifs du TDM"},{"location":"tdm10/#exercice-1-revision-http-avec-netcat","text":"Le protocole HTTP fonctionne au dessus du protocole TCP, il permet de manipuler des ressources distantes. Il est principalement utilis\u00e9 pour le web. Le client envoie des requ\u00eates avec le format suivant : Ligne de commande ( Commande, URL, Version de protocole ) En-t\u00eate de requ\u00eates [ Ligne vide ] Corps de requ\u00eate La ligne de commande indique ce que le client attend. Par exemple, pour obtenir la page d'accueil, on utilisera la commande : GET /index.html HTTP/1.1 Host : 192 .168.130.214 Connection: close [ Ligne vide ] L'ent\u00eate de requ\u00eate contient une succession de couples ( variable : valeur) , par exemple Host : 192.168.130.214. Elle permet au client de donner des informations \u00e0 son propos ou de pr\u00e9ciser la requ\u00eate. La ligne vide est tr\u00e8s importante elle distingue le header HTTP du reste du message. Le corps de la requ\u00eate peut contenir des donn\u00e9es additionnelles (dans le cas de messages POST par exemple) Le serveur r\u00e9pond avec un format similaire : Ligne de statut ( Version, Code r\u00e9ponse, Texte r\u00e9ponse ) En-t\u00eate de r\u00e9ponse [ Ligne vide ] Corps de r\u00e9ponse La ligne de status indique au client si sa requ\u00eate a r\u00e9ussi. Parmi les r\u00e9ponses possibles: HTTP/1.0 200 OK indique le succ\u00e8s de l'op\u00e9ration HTTP/1.0 404 Not Found, indique que la page demand\u00e9 n'existe pas. HTTP/1.0 418 I'm a teapot, indique que le serveur n'est pas un serveur HTTP mais une th\u00e9i\u00e8re (RFC 2324). L'ent\u00eate permet au serveur de pr\u00e9ciser la r\u00e9ponse par exemple en indiquant la taille et le type de la ressource demand\u00e9e. La ligne vide s\u00e9pare l'ent\u00eate de la ressource demand\u00e9e dans le corps du message. Naviguez sur le serveur de la salle avec un navigateur classique. L'URL est http://192.168.130.214/index.html Faites ensuite la m\u00eame navigation avec l'utilitaire netcat, en tapant directement \u00e0 la main les commandes HTTP (vous utiliserez le protocole HTTP/1.1). Prenez le temps de bien observer le contenu des \u00e9changes, et de comprendre comment fonctionne votre navigateur Web : combien de requ\u00eates HTTP doit il faire pour afficher une page, ...?","title":"Exercice 1\u00a0: R\u00e9vision HTTP avec netcat"},{"location":"tdm10/#exercice-2-decouverte-du-javascript","text":"Naviguez sur le serveur de la salle avec un navigateur classique, pour charger la page http://192.168.130.214/on_load.html Afficher le code source de page (faire clic droit dans le navigateur, view page source) Afficher le DOM apr\u00e8s l'\u00e9x\u00e9cution du Javascript (faire clic droit dans le navigateur, inspect) Coment se passe le chargement d'une page WEB ?","title":"Exercice 2\u00a0: D\u00e9couverte du JavaScript"},{"location":"tdm10/#exercice-3-suite-javascript","text":"Naviguez sur le serveur de la salle avec un navigateur classique, pour charger la page http://192.168.130.214/button.html Afficher le code source de page (faire clic droit dans le navigateur, view page source) Afficher le DOM apr\u00e8s l'\u00e9x\u00e9cution du Javascript (faire clic droit dans le navigateur, inspect) Cliquer ensuite sur le bouton \"Click me\" de la page WEB Afficher le code source de page (faire clic droit dans le navigateur, view page source) Afficher le DOM apr\u00e8s l'\u00e9x\u00e9cution du Javascript (faire clic droit dans le navigateur, inspect) Faites maintenant une recherche internet pour en savoir sur les SPA : Single Page Application MPA : Mulptiple Page Application","title":"Exercice 3\u00a0: Suite JavaScript"},{"location":"tdm10/#exercice-4-realisation-dun-client-http-avec-extraction-de-flux-video","text":"T\u00e9l\u00e9charger le fichier http-image.jar http-image.jar Placez vous dans le repertoire o\u00f9 vous avez t\u00e9l\u00e9charg\u00e9 ce fichier, et lancez ce serveur HTTP avec la commande java -jar http-image.jar Ensuite, lancez un navigateur WEB sur l'url http://127.0.0.1:8000 Observez la page qui s'affiche. Cette technique est notamment utilis\u00e9e par les WEBCAM. Faites du reverse engineering avec wireshark pour voir le flux qui est envoy\u00e9. D\u00e9veloppez maintenant un client Java qui interroge ce client HTTP, et qui est capable d'extraire les images envoy\u00e9es et de les sauvegarder dans des fichiers (par image01.bmp, image02.bmp, ...)","title":"Exercice 4\u00a0:  R\u00e9alisation d'un client HTTP avec extraction de flux vid\u00e9o"},{"location":"tdm10/#exercice-5-realisation-dun-serveur-http-avec-flux-video","text":"D\u00e9veloppez ensuite votre propre serveur HTTP qui aura un rendu similaire \u00e0 celui fourni. Pour cr\u00e9er une image bitmap, vous pouvez utiliser les deux classes Java BufferedImage et ImageIO (ces deux classes sont comprises dans le langage Java de base et permettent la cr\u00e9ation d'image au format BMP ou autre).","title":"Exercice 5\u00a0:  R\u00e9alisation d'un serveur HTTP avec flux vid\u00e9o"},{"location":"tdm10/#exercice-6-realisation-dune-balle-rebondissante-multi-ecrans","text":"D\u00e9veloppez maintenant votre propre serveur HTTP, qui fourni un flux vid\u00e9o avec une balle redondissante \u00e0 l'int\u00e9rieur. Si deux navigateurs sont connect\u00e9s \u00e0 votre serveur, alors la balle doit rebondir entre les deux navigateurs.","title":"Exercice 6\u00a0:  R\u00e9alisation d'une balle rebondissante multi \u00e9crans"},{"location":"tdm10/#exercice-7-realisation-dun-serveur-http-de-fichiers","text":"Vous allez maintenant r\u00e9aliser un serveur HTTP, qui affiche une page d'accueil et une autre page permettant de t\u00e9l\u00e9charger des fichiers. R\u00e9aliser un serveur TCP qui \u00e9coute les connexions entrantes, et qui v\u00e9rifie que la requ\u00eate commence par le mot GET . Si la page demand\u00e9e est /index.html, alors votre serveur renvoie une page fixe (vous afficherez par exemple simplement une page HTML avec le message \u00ab Bonjour \u00bb). Si la page demand\u00e9e est /fichiers.html, alors votre serveur renvoie une page avec la liste des fichiers disponibles au t\u00e9l\u00e9chargement, et il est possible de cliquer sur un lien pour lancer le t\u00e9l\u00e9chargement. Tester votre serveur avec un navigateur web en demandant la page \" http://localhost:port/index.html \" o\u00f9 port est le port d'\u00e9coute de votre serveur. V\u00e9rifier que le t\u00e9l\u00e9chargement des fichiers se d\u00e9roule correctement.","title":"Exercice 7\u00a0:  R\u00e9alisation d'un serveur HTTP de fichiers"}]}